import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
} from './runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Query Engine version: 76857c35ba1e1764dd5473656ecbbb2f739e1822
 * Prisma Client JS version: 2.0.0-beta.2
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}


declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export declare type TrueKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string, collectTimestamps?: any): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/


export type Datasources = {
  db?: string
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  datasources?: Datasources

  /**
   * @default "pretty"
   */
  errorFormat?: ErrorFormat

  log?: Array<LogLevel | LogDefinition>

  /**
   * You probably don't want to use this. `__internal` is used by internal tooling.
   */
  __internal?: {
    debug?: boolean
    hooks?: Hooks
    engine?: {
      cwd?: string
      binaryPath?: string
    }
    measurePerformance?: boolean
  }

  /**
   * Useful for pgbouncer
   */
  forceTransactions?: boolean
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]>

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Conversations
 * const conversations = await prisma.conversation.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
 */
export declare class PrismaClient<T extends PrismaClientOptions = {}, U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Conversations
   * const conversations = await prisma.conversation.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
   */
  constructor(optionsArg?: T);
  on<V extends U>(eventType: V, callback: V extends never ? never : (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  connect(): Promise<void>;
  /**
   * @private
   */
  private runDisconnect;
  /**
   * Disconnect from the database
   */
  disconnect(): Promise<any>;
  /**
   * Makes a raw query
   * @example
   * ```
   * // Fetch all entries from the `User` table
   * const result = await prisma.raw`SELECT * FROM User;`
   * // Or
   * const result = await prisma.raw('SELECT * FROM User;')
   * 
   * // With parameters use prisma.raw``, values will be escaped automatically
   * const userId = '1'
   * const result = await prisma.raw`SELECT * FROM User WHERE id = ${userId};`
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  raw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): conversationDelegate;

  /**
   * `prisma.like`: Exposes CRUD operations for the **like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): likeDelegate;

  /**
   * `prisma.list`: Exposes CRUD operations for the **list** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lists
    * const lists = await prisma.list.findMany()
    * ```
    */
  get list(): listDelegate;

  /**
   * `prisma.message`: Exposes CRUD operations for the **message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): messageDelegate;

  /**
   * `prisma.movie`: Exposes CRUD operations for the **movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movie.findMany()
    * ```
    */
  get movie(): movieDelegate;

  /**
   * `prisma.photo`: Exposes CRUD operations for the **photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photo.findMany()
    * ```
    */
  get photo(): photoDelegate;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): reservationDelegate;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): reviewDelegate;

  /**
   * `prisma.room`: Exposes CRUD operations for the **room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): roomDelegate;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): userDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const OrderByArg: {
  asc: 'asc',
  desc: 'desc'
};

export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg]



/**
 * Model conversation
 */

export type conversation = {
  id: number
}

export type conversationSelect = {
  id?: boolean
  message?: boolean | messageArgs
}

export type conversationInclude = {
  message?: boolean | messageArgs
}

export type conversationGetPayload<
  S extends boolean | null | undefined | conversationArgs,
  U = keyof S
> = S extends true
  ? conversation
  : S extends undefined
  ? never
  : S extends FindManyconversationArgs
  ? 'include' extends U
    ? conversation  & {
      [P in TrueKeys<S['include']>]:
      P extends 'message'
      ? messageGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof conversation ? conversation[P]
: 
      P extends 'message'
      ? messageGetPayload<S['select'][P]> | null : never
    }
  : conversation
: conversation


export interface conversationDelegate {
  /**
   * Find zero or one Conversation.
   * @param {FindOneconversationArgs} args - Arguments to find a Conversation
   * @example
   * // Get one Conversation
   * const conversation = await prisma.conversation.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneconversationArgs>(
    args: Subset<T, FindOneconversationArgs>
  ): CheckSelect<T, conversationClient<conversation | null>, conversationClient<conversationGetPayload<T> | null>>
  /**
   * Find zero or more Conversations.
   * @param {FindManyconversationArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Conversations
   * const conversations = await prisma.conversation.findMany()
   * 
   * // Get first 10 Conversations
   * const conversations = await prisma.conversation.findMany({ first: 10 })
   * 
   * // Only select the `id`
   * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyconversationArgs>(
    args?: Subset<T, FindManyconversationArgs>
  ): CheckSelect<T, Promise<Array<conversation>>, Promise<Array<conversationGetPayload<T>>>>
  /**
   * Create a Conversation.
   * @param {conversationCreateArgs} args - Arguments to create a Conversation.
   * @example
   * // Create one Conversation
   * const user = await prisma.conversation.create({
   *   data: {
   *     // ... data to create a Conversation
   *   }
   * })
   * 
  **/
  create<T extends conversationCreateArgs>(
    args: Subset<T, conversationCreateArgs>
  ): CheckSelect<T, conversationClient<conversation>, conversationClient<conversationGetPayload<T>>>
  /**
   * Delete a Conversation.
   * @param {conversationDeleteArgs} args - Arguments to delete one Conversation.
   * @example
   * // Delete one Conversation
   * const user = await prisma.conversation.delete({
   *   where: {
   *     // ... filter to delete one Conversation
   *   }
   * })
   * 
  **/
  delete<T extends conversationDeleteArgs>(
    args: Subset<T, conversationDeleteArgs>
  ): CheckSelect<T, conversationClient<conversation>, conversationClient<conversationGetPayload<T>>>
  /**
   * Update one Conversation.
   * @param {conversationUpdateArgs} args - Arguments to update one Conversation.
   * @example
   * // Update one Conversation
   * const conversation = await prisma.conversation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends conversationUpdateArgs>(
    args: Subset<T, conversationUpdateArgs>
  ): CheckSelect<T, conversationClient<conversation>, conversationClient<conversationGetPayload<T>>>
  /**
   * Delete zero or more Conversations.
   * @param {conversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
   * @example
   * // Delete a few Conversations
   * const { count } = await prisma.conversation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends conversationDeleteManyArgs>(
    args: Subset<T, conversationDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Conversations.
   * @param {conversationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Conversations
   * const conversation = await prisma.conversation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends conversationUpdateManyArgs>(
    args: Subset<T, conversationUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Conversation.
   * @param {conversationUpsertArgs} args - Arguments to update or create a Conversation.
   * @example
   * // Update or create a Conversation
   * const conversation = await prisma.conversation.upsert({
   *   create: {
   *     // ... data to create a Conversation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Conversation we want to update
   *   }
   * })
  **/
  upsert<T extends conversationUpsertArgs>(
    args: Subset<T, conversationUpsertArgs>
  ): CheckSelect<T, conversationClient<conversation>, conversationClient<conversationGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyconversationArgs, 'select' | 'include'>): Promise<number>
}

export declare class conversationClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  message<T extends messageArgs = {}>(args?: Subset<T, messageArgs>): CheckSelect<T, messageClient<message | null>, messageClient<messageGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * conversation findOne
 */
export type FindOneconversationArgs = {
  /**
   * Select specific fields to fetch from the conversation
  **/
  select?: conversationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: conversationInclude | null
  /**
   * Filter, which conversation to fetch.
  **/
  where: conversationWhereUniqueInput
}


/**
 * conversation findMany
 */
export type FindManyconversationArgs = {
  /**
   * Select specific fields to fetch from the conversation
  **/
  select?: conversationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: conversationInclude | null
  /**
   * Filter, which conversations to fetch.
  **/
  where?: conversationWhereInput | null
  /**
   * Determine the order of the conversations to fetch.
  **/
  orderBy?: conversationOrderByInput | null
  /**
   * Skip the first `n` conversations.
  **/
  skip?: number | null
  /**
   * Get all conversations that come after the conversation you provide with the current order.
  **/
  after?: conversationWhereUniqueInput | null
  /**
   * Get all conversations that come before the conversation you provide with the current order.
  **/
  before?: conversationWhereUniqueInput | null
  /**
   * Get the first `n` conversations.
  **/
  first?: number | null
  /**
   * Get the last `n` conversations.
  **/
  last?: number | null
}


/**
 * conversation create
 */
export type conversationCreateArgs = {
  /**
   * Select specific fields to fetch from the conversation
  **/
  select?: conversationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: conversationInclude | null
  /**
   * The data needed to create a conversation.
  **/
  data: conversationCreateInput
}


/**
 * conversation update
 */
export type conversationUpdateArgs = {
  /**
   * Select specific fields to fetch from the conversation
  **/
  select?: conversationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: conversationInclude | null
  /**
   * The data needed to update a conversation.
  **/
  data: conversationUpdateInput
  /**
   * Choose, which conversation to update.
  **/
  where: conversationWhereUniqueInput
}


/**
 * conversation updateMany
 */
export type conversationUpdateManyArgs = {
  data: conversationUpdateManyMutationInput
  where?: conversationWhereInput | null
}


/**
 * conversation upsert
 */
export type conversationUpsertArgs = {
  /**
   * Select specific fields to fetch from the conversation
  **/
  select?: conversationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: conversationInclude | null
  /**
   * The filter to search for the conversation to update in case it exists.
  **/
  where: conversationWhereUniqueInput
  /**
   * In case the conversation found by the `where` argument doesn't exist, create a new conversation with this data.
  **/
  create: conversationCreateInput
  /**
   * In case the conversation was found with the provided `where` argument, update it with this data.
  **/
  update: conversationUpdateInput
}


/**
 * conversation delete
 */
export type conversationDeleteArgs = {
  /**
   * Select specific fields to fetch from the conversation
  **/
  select?: conversationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: conversationInclude | null
  /**
   * Filter which conversation to delete.
  **/
  where: conversationWhereUniqueInput
}


/**
 * conversation deleteMany
 */
export type conversationDeleteManyArgs = {
  where?: conversationWhereInput | null
}


/**
 * conversation without action
 */
export type conversationArgs = {
  /**
   * Select specific fields to fetch from the conversation
  **/
  select?: conversationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: conversationInclude | null
}



/**
 * Model like
 */

export type like = {
  id: number
  roomId: number
  userId: number
}

export type likeSelect = {
  id?: boolean
  roomId?: boolean
  userId?: boolean
  room?: boolean | roomArgs
  user?: boolean | userArgs
}

export type likeInclude = {
  room?: boolean | roomArgs
  user?: boolean | userArgs
}

export type likeGetPayload<
  S extends boolean | null | undefined | likeArgs,
  U = keyof S
> = S extends true
  ? like
  : S extends undefined
  ? never
  : S extends FindManylikeArgs
  ? 'include' extends U
    ? like  & {
      [P in TrueKeys<S['include']>]:
      P extends 'room'
      ? roomGetPayload<S['include'][P]> :
      P extends 'user'
      ? userGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof like ? like[P]
: 
      P extends 'room'
      ? roomGetPayload<S['select'][P]> :
      P extends 'user'
      ? userGetPayload<S['select'][P]> : never
    }
  : like
: like


export interface likeDelegate {
  /**
   * Find zero or one Like.
   * @param {FindOnelikeArgs} args - Arguments to find a Like
   * @example
   * // Get one Like
   * const like = await prisma.like.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnelikeArgs>(
    args: Subset<T, FindOnelikeArgs>
  ): CheckSelect<T, likeClient<like | null>, likeClient<likeGetPayload<T> | null>>
  /**
   * Find zero or more Likes.
   * @param {FindManylikeArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Likes
   * const likes = await prisma.like.findMany()
   * 
   * // Get first 10 Likes
   * const likes = await prisma.like.findMany({ first: 10 })
   * 
   * // Only select the `id`
   * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManylikeArgs>(
    args?: Subset<T, FindManylikeArgs>
  ): CheckSelect<T, Promise<Array<like>>, Promise<Array<likeGetPayload<T>>>>
  /**
   * Create a Like.
   * @param {likeCreateArgs} args - Arguments to create a Like.
   * @example
   * // Create one Like
   * const user = await prisma.like.create({
   *   data: {
   *     // ... data to create a Like
   *   }
   * })
   * 
  **/
  create<T extends likeCreateArgs>(
    args: Subset<T, likeCreateArgs>
  ): CheckSelect<T, likeClient<like>, likeClient<likeGetPayload<T>>>
  /**
   * Delete a Like.
   * @param {likeDeleteArgs} args - Arguments to delete one Like.
   * @example
   * // Delete one Like
   * const user = await prisma.like.delete({
   *   where: {
   *     // ... filter to delete one Like
   *   }
   * })
   * 
  **/
  delete<T extends likeDeleteArgs>(
    args: Subset<T, likeDeleteArgs>
  ): CheckSelect<T, likeClient<like>, likeClient<likeGetPayload<T>>>
  /**
   * Update one Like.
   * @param {likeUpdateArgs} args - Arguments to update one Like.
   * @example
   * // Update one Like
   * const like = await prisma.like.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends likeUpdateArgs>(
    args: Subset<T, likeUpdateArgs>
  ): CheckSelect<T, likeClient<like>, likeClient<likeGetPayload<T>>>
  /**
   * Delete zero or more Likes.
   * @param {likeDeleteManyArgs} args - Arguments to filter Likes to delete.
   * @example
   * // Delete a few Likes
   * const { count } = await prisma.like.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends likeDeleteManyArgs>(
    args: Subset<T, likeDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Likes.
   * @param {likeUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Likes
   * const like = await prisma.like.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends likeUpdateManyArgs>(
    args: Subset<T, likeUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Like.
   * @param {likeUpsertArgs} args - Arguments to update or create a Like.
   * @example
   * // Update or create a Like
   * const like = await prisma.like.upsert({
   *   create: {
   *     // ... data to create a Like
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Like we want to update
   *   }
   * })
  **/
  upsert<T extends likeUpsertArgs>(
    args: Subset<T, likeUpsertArgs>
  ): CheckSelect<T, likeClient<like>, likeClient<likeGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManylikeArgs, 'select' | 'include'>): Promise<number>
}

export declare class likeClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  room<T extends roomArgs = {}>(args?: Subset<T, roomArgs>): CheckSelect<T, roomClient<room | null>, roomClient<roomGetPayload<T> | null>>;

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, userClient<user | null>, userClient<userGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * like findOne
 */
export type FindOnelikeArgs = {
  /**
   * Select specific fields to fetch from the like
  **/
  select?: likeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: likeInclude | null
  /**
   * Filter, which like to fetch.
  **/
  where: likeWhereUniqueInput
}


/**
 * like findMany
 */
export type FindManylikeArgs = {
  /**
   * Select specific fields to fetch from the like
  **/
  select?: likeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: likeInclude | null
  /**
   * Filter, which likes to fetch.
  **/
  where?: likeWhereInput | null
  /**
   * Determine the order of the likes to fetch.
  **/
  orderBy?: likeOrderByInput | null
  /**
   * Skip the first `n` likes.
  **/
  skip?: number | null
  /**
   * Get all likes that come after the like you provide with the current order.
  **/
  after?: likeWhereUniqueInput | null
  /**
   * Get all likes that come before the like you provide with the current order.
  **/
  before?: likeWhereUniqueInput | null
  /**
   * Get the first `n` likes.
  **/
  first?: number | null
  /**
   * Get the last `n` likes.
  **/
  last?: number | null
}


/**
 * like create
 */
export type likeCreateArgs = {
  /**
   * Select specific fields to fetch from the like
  **/
  select?: likeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: likeInclude | null
  /**
   * The data needed to create a like.
  **/
  data: likeCreateInput
}


/**
 * like update
 */
export type likeUpdateArgs = {
  /**
   * Select specific fields to fetch from the like
  **/
  select?: likeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: likeInclude | null
  /**
   * The data needed to update a like.
  **/
  data: likeUpdateInput
  /**
   * Choose, which like to update.
  **/
  where: likeWhereUniqueInput
}


/**
 * like updateMany
 */
export type likeUpdateManyArgs = {
  data: likeUpdateManyMutationInput
  where?: likeWhereInput | null
}


/**
 * like upsert
 */
export type likeUpsertArgs = {
  /**
   * Select specific fields to fetch from the like
  **/
  select?: likeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: likeInclude | null
  /**
   * The filter to search for the like to update in case it exists.
  **/
  where: likeWhereUniqueInput
  /**
   * In case the like found by the `where` argument doesn't exist, create a new like with this data.
  **/
  create: likeCreateInput
  /**
   * In case the like was found with the provided `where` argument, update it with this data.
  **/
  update: likeUpdateInput
}


/**
 * like delete
 */
export type likeDeleteArgs = {
  /**
   * Select specific fields to fetch from the like
  **/
  select?: likeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: likeInclude | null
  /**
   * Filter which like to delete.
  **/
  where: likeWhereUniqueInput
}


/**
 * like deleteMany
 */
export type likeDeleteManyArgs = {
  where?: likeWhereInput | null
}


/**
 * like without action
 */
export type likeArgs = {
  /**
   * Select specific fields to fetch from the like
  **/
  select?: likeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: likeInclude | null
}



/**
 * Model list
 */

export type list = {
  id: number
  name: string
  userId: number | null
}

export type listSelect = {
  id?: boolean
  name?: boolean
  userId?: boolean
  user?: boolean | userArgs
}

export type listInclude = {
  user?: boolean | userArgs
}

export type listGetPayload<
  S extends boolean | null | undefined | listArgs,
  U = keyof S
> = S extends true
  ? list
  : S extends undefined
  ? never
  : S extends FindManylistArgs
  ? 'include' extends U
    ? list  & {
      [P in TrueKeys<S['include']>]:
      P extends 'user'
      ? userGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof list ? list[P]
: 
      P extends 'user'
      ? userGetPayload<S['select'][P]> | null : never
    }
  : list
: list


export interface listDelegate {
  /**
   * Find zero or one List.
   * @param {FindOnelistArgs} args - Arguments to find a List
   * @example
   * // Get one List
   * const list = await prisma.list.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnelistArgs>(
    args: Subset<T, FindOnelistArgs>
  ): CheckSelect<T, listClient<list | null>, listClient<listGetPayload<T> | null>>
  /**
   * Find zero or more Lists.
   * @param {FindManylistArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Lists
   * const lists = await prisma.list.findMany()
   * 
   * // Get first 10 Lists
   * const lists = await prisma.list.findMany({ first: 10 })
   * 
   * // Only select the `id`
   * const listWithIdOnly = await prisma.list.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManylistArgs>(
    args?: Subset<T, FindManylistArgs>
  ): CheckSelect<T, Promise<Array<list>>, Promise<Array<listGetPayload<T>>>>
  /**
   * Create a List.
   * @param {listCreateArgs} args - Arguments to create a List.
   * @example
   * // Create one List
   * const user = await prisma.list.create({
   *   data: {
   *     // ... data to create a List
   *   }
   * })
   * 
  **/
  create<T extends listCreateArgs>(
    args: Subset<T, listCreateArgs>
  ): CheckSelect<T, listClient<list>, listClient<listGetPayload<T>>>
  /**
   * Delete a List.
   * @param {listDeleteArgs} args - Arguments to delete one List.
   * @example
   * // Delete one List
   * const user = await prisma.list.delete({
   *   where: {
   *     // ... filter to delete one List
   *   }
   * })
   * 
  **/
  delete<T extends listDeleteArgs>(
    args: Subset<T, listDeleteArgs>
  ): CheckSelect<T, listClient<list>, listClient<listGetPayload<T>>>
  /**
   * Update one List.
   * @param {listUpdateArgs} args - Arguments to update one List.
   * @example
   * // Update one List
   * const list = await prisma.list.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends listUpdateArgs>(
    args: Subset<T, listUpdateArgs>
  ): CheckSelect<T, listClient<list>, listClient<listGetPayload<T>>>
  /**
   * Delete zero or more Lists.
   * @param {listDeleteManyArgs} args - Arguments to filter Lists to delete.
   * @example
   * // Delete a few Lists
   * const { count } = await prisma.list.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends listDeleteManyArgs>(
    args: Subset<T, listDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Lists.
   * @param {listUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Lists
   * const list = await prisma.list.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends listUpdateManyArgs>(
    args: Subset<T, listUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one List.
   * @param {listUpsertArgs} args - Arguments to update or create a List.
   * @example
   * // Update or create a List
   * const list = await prisma.list.upsert({
   *   create: {
   *     // ... data to create a List
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the List we want to update
   *   }
   * })
  **/
  upsert<T extends listUpsertArgs>(
    args: Subset<T, listUpsertArgs>
  ): CheckSelect<T, listClient<list>, listClient<listGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManylistArgs, 'select' | 'include'>): Promise<number>
}

export declare class listClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, userClient<user | null>, userClient<userGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * list findOne
 */
export type FindOnelistArgs = {
  /**
   * Select specific fields to fetch from the list
  **/
  select?: listSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: listInclude | null
  /**
   * Filter, which list to fetch.
  **/
  where: listWhereUniqueInput
}


/**
 * list findMany
 */
export type FindManylistArgs = {
  /**
   * Select specific fields to fetch from the list
  **/
  select?: listSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: listInclude | null
  /**
   * Filter, which lists to fetch.
  **/
  where?: listWhereInput | null
  /**
   * Determine the order of the lists to fetch.
  **/
  orderBy?: listOrderByInput | null
  /**
   * Skip the first `n` lists.
  **/
  skip?: number | null
  /**
   * Get all lists that come after the list you provide with the current order.
  **/
  after?: listWhereUniqueInput | null
  /**
   * Get all lists that come before the list you provide with the current order.
  **/
  before?: listWhereUniqueInput | null
  /**
   * Get the first `n` lists.
  **/
  first?: number | null
  /**
   * Get the last `n` lists.
  **/
  last?: number | null
}


/**
 * list create
 */
export type listCreateArgs = {
  /**
   * Select specific fields to fetch from the list
  **/
  select?: listSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: listInclude | null
  /**
   * The data needed to create a list.
  **/
  data: listCreateInput
}


/**
 * list update
 */
export type listUpdateArgs = {
  /**
   * Select specific fields to fetch from the list
  **/
  select?: listSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: listInclude | null
  /**
   * The data needed to update a list.
  **/
  data: listUpdateInput
  /**
   * Choose, which list to update.
  **/
  where: listWhereUniqueInput
}


/**
 * list updateMany
 */
export type listUpdateManyArgs = {
  data: listUpdateManyMutationInput
  where?: listWhereInput | null
}


/**
 * list upsert
 */
export type listUpsertArgs = {
  /**
   * Select specific fields to fetch from the list
  **/
  select?: listSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: listInclude | null
  /**
   * The filter to search for the list to update in case it exists.
  **/
  where: listWhereUniqueInput
  /**
   * In case the list found by the `where` argument doesn't exist, create a new list with this data.
  **/
  create: listCreateInput
  /**
   * In case the list was found with the provided `where` argument, update it with this data.
  **/
  update: listUpdateInput
}


/**
 * list delete
 */
export type listDeleteArgs = {
  /**
   * Select specific fields to fetch from the list
  **/
  select?: listSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: listInclude | null
  /**
   * Filter which list to delete.
  **/
  where: listWhereUniqueInput
}


/**
 * list deleteMany
 */
export type listDeleteManyArgs = {
  where?: listWhereInput | null
}


/**
 * list without action
 */
export type listArgs = {
  /**
   * Select specific fields to fetch from the list
  **/
  select?: listSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: listInclude | null
}



/**
 * Model message
 */

export type message = {
  conversationId: number | null
  id: number
  message: string
  userId: number | null
}

export type messageSelect = {
  conversationId?: boolean
  id?: boolean
  message?: boolean
  userId?: boolean
  conversation?: boolean | conversationArgs
  user?: boolean | userArgs
}

export type messageInclude = {
  conversation?: boolean | conversationArgs
  user?: boolean | userArgs
}

export type messageGetPayload<
  S extends boolean | null | undefined | messageArgs,
  U = keyof S
> = S extends true
  ? message
  : S extends undefined
  ? never
  : S extends FindManymessageArgs
  ? 'include' extends U
    ? message  & {
      [P in TrueKeys<S['include']>]:
      P extends 'conversation'
      ? conversationGetPayload<S['include'][P]> | null :
      P extends 'user'
      ? userGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof message ? message[P]
: 
      P extends 'conversation'
      ? conversationGetPayload<S['select'][P]> | null :
      P extends 'user'
      ? userGetPayload<S['select'][P]> | null : never
    }
  : message
: message


export interface messageDelegate {
  /**
   * Find zero or one Message.
   * @param {FindOnemessageArgs} args - Arguments to find a Message
   * @example
   * // Get one Message
   * const message = await prisma.message.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnemessageArgs>(
    args: Subset<T, FindOnemessageArgs>
  ): CheckSelect<T, messageClient<message | null>, messageClient<messageGetPayload<T> | null>>
  /**
   * Find zero or more Messages.
   * @param {FindManymessageArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Messages
   * const messages = await prisma.message.findMany()
   * 
   * // Get first 10 Messages
   * const messages = await prisma.message.findMany({ first: 10 })
   * 
   * // Only select the `conversationId`
   * const messageWithConversationIdOnly = await prisma.message.findMany({ select: { conversationId: true } })
   * 
  **/
  findMany<T extends FindManymessageArgs>(
    args?: Subset<T, FindManymessageArgs>
  ): CheckSelect<T, Promise<Array<message>>, Promise<Array<messageGetPayload<T>>>>
  /**
   * Create a Message.
   * @param {messageCreateArgs} args - Arguments to create a Message.
   * @example
   * // Create one Message
   * const user = await prisma.message.create({
   *   data: {
   *     // ... data to create a Message
   *   }
   * })
   * 
  **/
  create<T extends messageCreateArgs>(
    args: Subset<T, messageCreateArgs>
  ): CheckSelect<T, messageClient<message>, messageClient<messageGetPayload<T>>>
  /**
   * Delete a Message.
   * @param {messageDeleteArgs} args - Arguments to delete one Message.
   * @example
   * // Delete one Message
   * const user = await prisma.message.delete({
   *   where: {
   *     // ... filter to delete one Message
   *   }
   * })
   * 
  **/
  delete<T extends messageDeleteArgs>(
    args: Subset<T, messageDeleteArgs>
  ): CheckSelect<T, messageClient<message>, messageClient<messageGetPayload<T>>>
  /**
   * Update one Message.
   * @param {messageUpdateArgs} args - Arguments to update one Message.
   * @example
   * // Update one Message
   * const message = await prisma.message.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends messageUpdateArgs>(
    args: Subset<T, messageUpdateArgs>
  ): CheckSelect<T, messageClient<message>, messageClient<messageGetPayload<T>>>
  /**
   * Delete zero or more Messages.
   * @param {messageDeleteManyArgs} args - Arguments to filter Messages to delete.
   * @example
   * // Delete a few Messages
   * const { count } = await prisma.message.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends messageDeleteManyArgs>(
    args: Subset<T, messageDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Messages.
   * @param {messageUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Messages
   * const message = await prisma.message.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends messageUpdateManyArgs>(
    args: Subset<T, messageUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Message.
   * @param {messageUpsertArgs} args - Arguments to update or create a Message.
   * @example
   * // Update or create a Message
   * const message = await prisma.message.upsert({
   *   create: {
   *     // ... data to create a Message
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Message we want to update
   *   }
   * })
  **/
  upsert<T extends messageUpsertArgs>(
    args: Subset<T, messageUpsertArgs>
  ): CheckSelect<T, messageClient<message>, messageClient<messageGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManymessageArgs, 'select' | 'include'>): Promise<number>
}

export declare class messageClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  conversation<T extends conversationArgs = {}>(args?: Subset<T, conversationArgs>): CheckSelect<T, conversationClient<conversation | null>, conversationClient<conversationGetPayload<T> | null>>;

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, userClient<user | null>, userClient<userGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * message findOne
 */
export type FindOnemessageArgs = {
  /**
   * Select specific fields to fetch from the message
  **/
  select?: messageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: messageInclude | null
  /**
   * Filter, which message to fetch.
  **/
  where: messageWhereUniqueInput
}


/**
 * message findMany
 */
export type FindManymessageArgs = {
  /**
   * Select specific fields to fetch from the message
  **/
  select?: messageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: messageInclude | null
  /**
   * Filter, which messages to fetch.
  **/
  where?: messageWhereInput | null
  /**
   * Determine the order of the messages to fetch.
  **/
  orderBy?: messageOrderByInput | null
  /**
   * Skip the first `n` messages.
  **/
  skip?: number | null
  /**
   * Get all messages that come after the message you provide with the current order.
  **/
  after?: messageWhereUniqueInput | null
  /**
   * Get all messages that come before the message you provide with the current order.
  **/
  before?: messageWhereUniqueInput | null
  /**
   * Get the first `n` messages.
  **/
  first?: number | null
  /**
   * Get the last `n` messages.
  **/
  last?: number | null
}


/**
 * message create
 */
export type messageCreateArgs = {
  /**
   * Select specific fields to fetch from the message
  **/
  select?: messageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: messageInclude | null
  /**
   * The data needed to create a message.
  **/
  data: messageCreateInput
}


/**
 * message update
 */
export type messageUpdateArgs = {
  /**
   * Select specific fields to fetch from the message
  **/
  select?: messageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: messageInclude | null
  /**
   * The data needed to update a message.
  **/
  data: messageUpdateInput
  /**
   * Choose, which message to update.
  **/
  where: messageWhereUniqueInput
}


/**
 * message updateMany
 */
export type messageUpdateManyArgs = {
  data: messageUpdateManyMutationInput
  where?: messageWhereInput | null
}


/**
 * message upsert
 */
export type messageUpsertArgs = {
  /**
   * Select specific fields to fetch from the message
  **/
  select?: messageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: messageInclude | null
  /**
   * The filter to search for the message to update in case it exists.
  **/
  where: messageWhereUniqueInput
  /**
   * In case the message found by the `where` argument doesn't exist, create a new message with this data.
  **/
  create: messageCreateInput
  /**
   * In case the message was found with the provided `where` argument, update it with this data.
  **/
  update: messageUpdateInput
}


/**
 * message delete
 */
export type messageDeleteArgs = {
  /**
   * Select specific fields to fetch from the message
  **/
  select?: messageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: messageInclude | null
  /**
   * Filter which message to delete.
  **/
  where: messageWhereUniqueInput
}


/**
 * message deleteMany
 */
export type messageDeleteManyArgs = {
  where?: messageWhereInput | null
}


/**
 * message without action
 */
export type messageArgs = {
  /**
   * Select specific fields to fetch from the message
  **/
  select?: messageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: messageInclude | null
}



/**
 * Model movie
 */

export type movie = {
  id: number
  minutes: number
  title: string
}

export type movieSelect = {
  id?: boolean
  minutes?: boolean
  title?: boolean
}

export type movieGetPayload<
  S extends boolean | null | undefined | movieArgs,
  U = keyof S
> = S extends true
  ? movie
  : S extends undefined
  ? never
  : S extends FindManymovieArgs
  ? 'include' extends U
    ? movie 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof movie ? movie[P]
: 
 never
    }
  : movie
: movie


export interface movieDelegate {
  /**
   * Find zero or one Movie.
   * @param {FindOnemovieArgs} args - Arguments to find a Movie
   * @example
   * // Get one Movie
   * const movie = await prisma.movie.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnemovieArgs>(
    args: Subset<T, FindOnemovieArgs>
  ): CheckSelect<T, movieClient<movie | null>, movieClient<movieGetPayload<T> | null>>
  /**
   * Find zero or more Movies.
   * @param {FindManymovieArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Movies
   * const movies = await prisma.movie.findMany()
   * 
   * // Get first 10 Movies
   * const movies = await prisma.movie.findMany({ first: 10 })
   * 
   * // Only select the `id`
   * const movieWithIdOnly = await prisma.movie.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManymovieArgs>(
    args?: Subset<T, FindManymovieArgs>
  ): CheckSelect<T, Promise<Array<movie>>, Promise<Array<movieGetPayload<T>>>>
  /**
   * Create a Movie.
   * @param {movieCreateArgs} args - Arguments to create a Movie.
   * @example
   * // Create one Movie
   * const user = await prisma.movie.create({
   *   data: {
   *     // ... data to create a Movie
   *   }
   * })
   * 
  **/
  create<T extends movieCreateArgs>(
    args: Subset<T, movieCreateArgs>
  ): CheckSelect<T, movieClient<movie>, movieClient<movieGetPayload<T>>>
  /**
   * Delete a Movie.
   * @param {movieDeleteArgs} args - Arguments to delete one Movie.
   * @example
   * // Delete one Movie
   * const user = await prisma.movie.delete({
   *   where: {
   *     // ... filter to delete one Movie
   *   }
   * })
   * 
  **/
  delete<T extends movieDeleteArgs>(
    args: Subset<T, movieDeleteArgs>
  ): CheckSelect<T, movieClient<movie>, movieClient<movieGetPayload<T>>>
  /**
   * Update one Movie.
   * @param {movieUpdateArgs} args - Arguments to update one Movie.
   * @example
   * // Update one Movie
   * const movie = await prisma.movie.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends movieUpdateArgs>(
    args: Subset<T, movieUpdateArgs>
  ): CheckSelect<T, movieClient<movie>, movieClient<movieGetPayload<T>>>
  /**
   * Delete zero or more Movies.
   * @param {movieDeleteManyArgs} args - Arguments to filter Movies to delete.
   * @example
   * // Delete a few Movies
   * const { count } = await prisma.movie.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends movieDeleteManyArgs>(
    args: Subset<T, movieDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Movies.
   * @param {movieUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Movies
   * const movie = await prisma.movie.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends movieUpdateManyArgs>(
    args: Subset<T, movieUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Movie.
   * @param {movieUpsertArgs} args - Arguments to update or create a Movie.
   * @example
   * // Update or create a Movie
   * const movie = await prisma.movie.upsert({
   *   create: {
   *     // ... data to create a Movie
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Movie we want to update
   *   }
   * })
  **/
  upsert<T extends movieUpsertArgs>(
    args: Subset<T, movieUpsertArgs>
  ): CheckSelect<T, movieClient<movie>, movieClient<movieGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManymovieArgs, 'select' | 'include'>): Promise<number>
}

export declare class movieClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * movie findOne
 */
export type FindOnemovieArgs = {
  /**
   * Select specific fields to fetch from the movie
  **/
  select?: movieSelect | null
  /**
   * Filter, which movie to fetch.
  **/
  where: movieWhereUniqueInput
}


/**
 * movie findMany
 */
export type FindManymovieArgs = {
  /**
   * Select specific fields to fetch from the movie
  **/
  select?: movieSelect | null
  /**
   * Filter, which movies to fetch.
  **/
  where?: movieWhereInput | null
  /**
   * Determine the order of the movies to fetch.
  **/
  orderBy?: movieOrderByInput | null
  /**
   * Skip the first `n` movies.
  **/
  skip?: number | null
  /**
   * Get all movies that come after the movie you provide with the current order.
  **/
  after?: movieWhereUniqueInput | null
  /**
   * Get all movies that come before the movie you provide with the current order.
  **/
  before?: movieWhereUniqueInput | null
  /**
   * Get the first `n` movies.
  **/
  first?: number | null
  /**
   * Get the last `n` movies.
  **/
  last?: number | null
}


/**
 * movie create
 */
export type movieCreateArgs = {
  /**
   * Select specific fields to fetch from the movie
  **/
  select?: movieSelect | null
  /**
   * The data needed to create a movie.
  **/
  data: movieCreateInput
}


/**
 * movie update
 */
export type movieUpdateArgs = {
  /**
   * Select specific fields to fetch from the movie
  **/
  select?: movieSelect | null
  /**
   * The data needed to update a movie.
  **/
  data: movieUpdateInput
  /**
   * Choose, which movie to update.
  **/
  where: movieWhereUniqueInput
}


/**
 * movie updateMany
 */
export type movieUpdateManyArgs = {
  data: movieUpdateManyMutationInput
  where?: movieWhereInput | null
}


/**
 * movie upsert
 */
export type movieUpsertArgs = {
  /**
   * Select specific fields to fetch from the movie
  **/
  select?: movieSelect | null
  /**
   * The filter to search for the movie to update in case it exists.
  **/
  where: movieWhereUniqueInput
  /**
   * In case the movie found by the `where` argument doesn't exist, create a new movie with this data.
  **/
  create: movieCreateInput
  /**
   * In case the movie was found with the provided `where` argument, update it with this data.
  **/
  update: movieUpdateInput
}


/**
 * movie delete
 */
export type movieDeleteArgs = {
  /**
   * Select specific fields to fetch from the movie
  **/
  select?: movieSelect | null
  /**
   * Filter which movie to delete.
  **/
  where: movieWhereUniqueInput
}


/**
 * movie deleteMany
 */
export type movieDeleteManyArgs = {
  where?: movieWhereInput | null
}


/**
 * movie without action
 */
export type movieArgs = {
  /**
   * Select specific fields to fetch from the movie
  **/
  select?: movieSelect | null
}



/**
 * Model photo
 */

export type photo = {
  caption: string | null
  file: string | null
  hostId: number | null
  id: number
  roomId: number | null
}

export type photoSelect = {
  caption?: boolean
  file?: boolean
  hostId?: boolean
  id?: boolean
  roomId?: boolean
  room?: boolean | roomArgs
}

export type photoInclude = {
  room?: boolean | roomArgs
}

export type photoGetPayload<
  S extends boolean | null | undefined | photoArgs,
  U = keyof S
> = S extends true
  ? photo
  : S extends undefined
  ? never
  : S extends FindManyphotoArgs
  ? 'include' extends U
    ? photo  & {
      [P in TrueKeys<S['include']>]:
      P extends 'room'
      ? roomGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof photo ? photo[P]
: 
      P extends 'room'
      ? roomGetPayload<S['select'][P]> | null : never
    }
  : photo
: photo


export interface photoDelegate {
  /**
   * Find zero or one Photo.
   * @param {FindOnephotoArgs} args - Arguments to find a Photo
   * @example
   * // Get one Photo
   * const photo = await prisma.photo.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnephotoArgs>(
    args: Subset<T, FindOnephotoArgs>
  ): CheckSelect<T, photoClient<photo | null>, photoClient<photoGetPayload<T> | null>>
  /**
   * Find zero or more Photos.
   * @param {FindManyphotoArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Photos
   * const photos = await prisma.photo.findMany()
   * 
   * // Get first 10 Photos
   * const photos = await prisma.photo.findMany({ first: 10 })
   * 
   * // Only select the `caption`
   * const photoWithCaptionOnly = await prisma.photo.findMany({ select: { caption: true } })
   * 
  **/
  findMany<T extends FindManyphotoArgs>(
    args?: Subset<T, FindManyphotoArgs>
  ): CheckSelect<T, Promise<Array<photo>>, Promise<Array<photoGetPayload<T>>>>
  /**
   * Create a Photo.
   * @param {photoCreateArgs} args - Arguments to create a Photo.
   * @example
   * // Create one Photo
   * const user = await prisma.photo.create({
   *   data: {
   *     // ... data to create a Photo
   *   }
   * })
   * 
  **/
  create<T extends photoCreateArgs>(
    args: Subset<T, photoCreateArgs>
  ): CheckSelect<T, photoClient<photo>, photoClient<photoGetPayload<T>>>
  /**
   * Delete a Photo.
   * @param {photoDeleteArgs} args - Arguments to delete one Photo.
   * @example
   * // Delete one Photo
   * const user = await prisma.photo.delete({
   *   where: {
   *     // ... filter to delete one Photo
   *   }
   * })
   * 
  **/
  delete<T extends photoDeleteArgs>(
    args: Subset<T, photoDeleteArgs>
  ): CheckSelect<T, photoClient<photo>, photoClient<photoGetPayload<T>>>
  /**
   * Update one Photo.
   * @param {photoUpdateArgs} args - Arguments to update one Photo.
   * @example
   * // Update one Photo
   * const photo = await prisma.photo.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends photoUpdateArgs>(
    args: Subset<T, photoUpdateArgs>
  ): CheckSelect<T, photoClient<photo>, photoClient<photoGetPayload<T>>>
  /**
   * Delete zero or more Photos.
   * @param {photoDeleteManyArgs} args - Arguments to filter Photos to delete.
   * @example
   * // Delete a few Photos
   * const { count } = await prisma.photo.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends photoDeleteManyArgs>(
    args: Subset<T, photoDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Photos.
   * @param {photoUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Photos
   * const photo = await prisma.photo.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends photoUpdateManyArgs>(
    args: Subset<T, photoUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Photo.
   * @param {photoUpsertArgs} args - Arguments to update or create a Photo.
   * @example
   * // Update or create a Photo
   * const photo = await prisma.photo.upsert({
   *   create: {
   *     // ... data to create a Photo
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Photo we want to update
   *   }
   * })
  **/
  upsert<T extends photoUpsertArgs>(
    args: Subset<T, photoUpsertArgs>
  ): CheckSelect<T, photoClient<photo>, photoClient<photoGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyphotoArgs, 'select' | 'include'>): Promise<number>
}

export declare class photoClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  room<T extends roomArgs = {}>(args?: Subset<T, roomArgs>): CheckSelect<T, roomClient<room | null>, roomClient<roomGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * photo findOne
 */
export type FindOnephotoArgs = {
  /**
   * Select specific fields to fetch from the photo
  **/
  select?: photoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: photoInclude | null
  /**
   * Filter, which photo to fetch.
  **/
  where: photoWhereUniqueInput
}


/**
 * photo findMany
 */
export type FindManyphotoArgs = {
  /**
   * Select specific fields to fetch from the photo
  **/
  select?: photoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: photoInclude | null
  /**
   * Filter, which photos to fetch.
  **/
  where?: photoWhereInput | null
  /**
   * Determine the order of the photos to fetch.
  **/
  orderBy?: photoOrderByInput | null
  /**
   * Skip the first `n` photos.
  **/
  skip?: number | null
  /**
   * Get all photos that come after the photo you provide with the current order.
  **/
  after?: photoWhereUniqueInput | null
  /**
   * Get all photos that come before the photo you provide with the current order.
  **/
  before?: photoWhereUniqueInput | null
  /**
   * Get the first `n` photos.
  **/
  first?: number | null
  /**
   * Get the last `n` photos.
  **/
  last?: number | null
}


/**
 * photo create
 */
export type photoCreateArgs = {
  /**
   * Select specific fields to fetch from the photo
  **/
  select?: photoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: photoInclude | null
  /**
   * The data needed to create a photo.
  **/
  data: photoCreateInput
}


/**
 * photo update
 */
export type photoUpdateArgs = {
  /**
   * Select specific fields to fetch from the photo
  **/
  select?: photoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: photoInclude | null
  /**
   * The data needed to update a photo.
  **/
  data: photoUpdateInput
  /**
   * Choose, which photo to update.
  **/
  where: photoWhereUniqueInput
}


/**
 * photo updateMany
 */
export type photoUpdateManyArgs = {
  data: photoUpdateManyMutationInput
  where?: photoWhereInput | null
}


/**
 * photo upsert
 */
export type photoUpsertArgs = {
  /**
   * Select specific fields to fetch from the photo
  **/
  select?: photoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: photoInclude | null
  /**
   * The filter to search for the photo to update in case it exists.
  **/
  where: photoWhereUniqueInput
  /**
   * In case the photo found by the `where` argument doesn't exist, create a new photo with this data.
  **/
  create: photoCreateInput
  /**
   * In case the photo was found with the provided `where` argument, update it with this data.
  **/
  update: photoUpdateInput
}


/**
 * photo delete
 */
export type photoDeleteArgs = {
  /**
   * Select specific fields to fetch from the photo
  **/
  select?: photoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: photoInclude | null
  /**
   * Filter which photo to delete.
  **/
  where: photoWhereUniqueInput
}


/**
 * photo deleteMany
 */
export type photoDeleteManyArgs = {
  where?: photoWhereInput | null
}


/**
 * photo without action
 */
export type photoArgs = {
  /**
   * Select specific fields to fetch from the photo
  **/
  select?: photoSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: photoInclude | null
}



/**
 * Model reservation
 */

export type reservation = {
  check_in: Date | null
  check_out: Date | null
  guestId: number
  id: number
  in_progress: boolean | null
  is_finished: boolean | null
  roomId: number
}

export type reservationSelect = {
  check_in?: boolean
  check_out?: boolean
  guestId?: boolean
  id?: boolean
  in_progress?: boolean
  is_finished?: boolean
  roomId?: boolean
  user?: boolean | userArgs
  room?: boolean | roomArgs
}

export type reservationInclude = {
  user?: boolean | userArgs
  room?: boolean | roomArgs
}

export type reservationGetPayload<
  S extends boolean | null | undefined | reservationArgs,
  U = keyof S
> = S extends true
  ? reservation
  : S extends undefined
  ? never
  : S extends FindManyreservationArgs
  ? 'include' extends U
    ? reservation  & {
      [P in TrueKeys<S['include']>]:
      P extends 'user'
      ? userGetPayload<S['include'][P]> :
      P extends 'room'
      ? roomGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof reservation ? reservation[P]
: 
      P extends 'user'
      ? userGetPayload<S['select'][P]> :
      P extends 'room'
      ? roomGetPayload<S['select'][P]> : never
    }
  : reservation
: reservation


export interface reservationDelegate {
  /**
   * Find zero or one Reservation.
   * @param {FindOnereservationArgs} args - Arguments to find a Reservation
   * @example
   * // Get one Reservation
   * const reservation = await prisma.reservation.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnereservationArgs>(
    args: Subset<T, FindOnereservationArgs>
  ): CheckSelect<T, reservationClient<reservation | null>, reservationClient<reservationGetPayload<T> | null>>
  /**
   * Find zero or more Reservations.
   * @param {FindManyreservationArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Reservations
   * const reservations = await prisma.reservation.findMany()
   * 
   * // Get first 10 Reservations
   * const reservations = await prisma.reservation.findMany({ first: 10 })
   * 
   * // Only select the `check_in`
   * const reservationWithCheck_inOnly = await prisma.reservation.findMany({ select: { check_in: true } })
   * 
  **/
  findMany<T extends FindManyreservationArgs>(
    args?: Subset<T, FindManyreservationArgs>
  ): CheckSelect<T, Promise<Array<reservation>>, Promise<Array<reservationGetPayload<T>>>>
  /**
   * Create a Reservation.
   * @param {reservationCreateArgs} args - Arguments to create a Reservation.
   * @example
   * // Create one Reservation
   * const user = await prisma.reservation.create({
   *   data: {
   *     // ... data to create a Reservation
   *   }
   * })
   * 
  **/
  create<T extends reservationCreateArgs>(
    args: Subset<T, reservationCreateArgs>
  ): CheckSelect<T, reservationClient<reservation>, reservationClient<reservationGetPayload<T>>>
  /**
   * Delete a Reservation.
   * @param {reservationDeleteArgs} args - Arguments to delete one Reservation.
   * @example
   * // Delete one Reservation
   * const user = await prisma.reservation.delete({
   *   where: {
   *     // ... filter to delete one Reservation
   *   }
   * })
   * 
  **/
  delete<T extends reservationDeleteArgs>(
    args: Subset<T, reservationDeleteArgs>
  ): CheckSelect<T, reservationClient<reservation>, reservationClient<reservationGetPayload<T>>>
  /**
   * Update one Reservation.
   * @param {reservationUpdateArgs} args - Arguments to update one Reservation.
   * @example
   * // Update one Reservation
   * const reservation = await prisma.reservation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends reservationUpdateArgs>(
    args: Subset<T, reservationUpdateArgs>
  ): CheckSelect<T, reservationClient<reservation>, reservationClient<reservationGetPayload<T>>>
  /**
   * Delete zero or more Reservations.
   * @param {reservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
   * @example
   * // Delete a few Reservations
   * const { count } = await prisma.reservation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends reservationDeleteManyArgs>(
    args: Subset<T, reservationDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Reservations.
   * @param {reservationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Reservations
   * const reservation = await prisma.reservation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends reservationUpdateManyArgs>(
    args: Subset<T, reservationUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Reservation.
   * @param {reservationUpsertArgs} args - Arguments to update or create a Reservation.
   * @example
   * // Update or create a Reservation
   * const reservation = await prisma.reservation.upsert({
   *   create: {
   *     // ... data to create a Reservation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Reservation we want to update
   *   }
   * })
  **/
  upsert<T extends reservationUpsertArgs>(
    args: Subset<T, reservationUpsertArgs>
  ): CheckSelect<T, reservationClient<reservation>, reservationClient<reservationGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyreservationArgs, 'select' | 'include'>): Promise<number>
}

export declare class reservationClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, userClient<user | null>, userClient<userGetPayload<T> | null>>;

  room<T extends roomArgs = {}>(args?: Subset<T, roomArgs>): CheckSelect<T, roomClient<room | null>, roomClient<roomGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * reservation findOne
 */
export type FindOnereservationArgs = {
  /**
   * Select specific fields to fetch from the reservation
  **/
  select?: reservationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reservationInclude | null
  /**
   * Filter, which reservation to fetch.
  **/
  where: reservationWhereUniqueInput
}


/**
 * reservation findMany
 */
export type FindManyreservationArgs = {
  /**
   * Select specific fields to fetch from the reservation
  **/
  select?: reservationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reservationInclude | null
  /**
   * Filter, which reservations to fetch.
  **/
  where?: reservationWhereInput | null
  /**
   * Determine the order of the reservations to fetch.
  **/
  orderBy?: reservationOrderByInput | null
  /**
   * Skip the first `n` reservations.
  **/
  skip?: number | null
  /**
   * Get all reservations that come after the reservation you provide with the current order.
  **/
  after?: reservationWhereUniqueInput | null
  /**
   * Get all reservations that come before the reservation you provide with the current order.
  **/
  before?: reservationWhereUniqueInput | null
  /**
   * Get the first `n` reservations.
  **/
  first?: number | null
  /**
   * Get the last `n` reservations.
  **/
  last?: number | null
}


/**
 * reservation create
 */
export type reservationCreateArgs = {
  /**
   * Select specific fields to fetch from the reservation
  **/
  select?: reservationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reservationInclude | null
  /**
   * The data needed to create a reservation.
  **/
  data: reservationCreateInput
}


/**
 * reservation update
 */
export type reservationUpdateArgs = {
  /**
   * Select specific fields to fetch from the reservation
  **/
  select?: reservationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reservationInclude | null
  /**
   * The data needed to update a reservation.
  **/
  data: reservationUpdateInput
  /**
   * Choose, which reservation to update.
  **/
  where: reservationWhereUniqueInput
}


/**
 * reservation updateMany
 */
export type reservationUpdateManyArgs = {
  data: reservationUpdateManyMutationInput
  where?: reservationWhereInput | null
}


/**
 * reservation upsert
 */
export type reservationUpsertArgs = {
  /**
   * Select specific fields to fetch from the reservation
  **/
  select?: reservationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reservationInclude | null
  /**
   * The filter to search for the reservation to update in case it exists.
  **/
  where: reservationWhereUniqueInput
  /**
   * In case the reservation found by the `where` argument doesn't exist, create a new reservation with this data.
  **/
  create: reservationCreateInput
  /**
   * In case the reservation was found with the provided `where` argument, update it with this data.
  **/
  update: reservationUpdateInput
}


/**
 * reservation delete
 */
export type reservationDeleteArgs = {
  /**
   * Select specific fields to fetch from the reservation
  **/
  select?: reservationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reservationInclude | null
  /**
   * Filter which reservation to delete.
  **/
  where: reservationWhereUniqueInput
}


/**
 * reservation deleteMany
 */
export type reservationDeleteManyArgs = {
  where?: reservationWhereInput | null
}


/**
 * reservation without action
 */
export type reservationArgs = {
  /**
   * Select specific fields to fetch from the reservation
  **/
  select?: reservationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reservationInclude | null
}



/**
 * Model review
 */

export type review = {
  accuracy: number | null
  check_in: number | null
  cleanliness: number | null
  communication: number | null
  createdAt: string | null
  id: number
  location: number | null
  review: string | null
  roomId: number
  userId: number | null
  value: number | null
}

export type reviewSelect = {
  accuracy?: boolean
  check_in?: boolean
  cleanliness?: boolean
  communication?: boolean
  createdAt?: boolean
  id?: boolean
  location?: boolean
  review?: boolean
  roomId?: boolean
  userId?: boolean
  value?: boolean
  room?: boolean | roomArgs
  user?: boolean | userArgs
}

export type reviewInclude = {
  room?: boolean | roomArgs
  user?: boolean | userArgs
}

export type reviewGetPayload<
  S extends boolean | null | undefined | reviewArgs,
  U = keyof S
> = S extends true
  ? review
  : S extends undefined
  ? never
  : S extends FindManyreviewArgs
  ? 'include' extends U
    ? review  & {
      [P in TrueKeys<S['include']>]:
      P extends 'room'
      ? roomGetPayload<S['include'][P]> :
      P extends 'user'
      ? userGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof review ? review[P]
: 
      P extends 'room'
      ? roomGetPayload<S['select'][P]> :
      P extends 'user'
      ? userGetPayload<S['select'][P]> | null : never
    }
  : review
: review


export interface reviewDelegate {
  /**
   * Find zero or one Review.
   * @param {FindOnereviewArgs} args - Arguments to find a Review
   * @example
   * // Get one Review
   * const review = await prisma.review.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnereviewArgs>(
    args: Subset<T, FindOnereviewArgs>
  ): CheckSelect<T, reviewClient<review | null>, reviewClient<reviewGetPayload<T> | null>>
  /**
   * Find zero or more Reviews.
   * @param {FindManyreviewArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Reviews
   * const reviews = await prisma.review.findMany()
   * 
   * // Get first 10 Reviews
   * const reviews = await prisma.review.findMany({ first: 10 })
   * 
   * // Only select the `accuracy`
   * const reviewWithAccuracyOnly = await prisma.review.findMany({ select: { accuracy: true } })
   * 
  **/
  findMany<T extends FindManyreviewArgs>(
    args?: Subset<T, FindManyreviewArgs>
  ): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>
  /**
   * Create a Review.
   * @param {reviewCreateArgs} args - Arguments to create a Review.
   * @example
   * // Create one Review
   * const user = await prisma.review.create({
   *   data: {
   *     // ... data to create a Review
   *   }
   * })
   * 
  **/
  create<T extends reviewCreateArgs>(
    args: Subset<T, reviewCreateArgs>
  ): CheckSelect<T, reviewClient<review>, reviewClient<reviewGetPayload<T>>>
  /**
   * Delete a Review.
   * @param {reviewDeleteArgs} args - Arguments to delete one Review.
   * @example
   * // Delete one Review
   * const user = await prisma.review.delete({
   *   where: {
   *     // ... filter to delete one Review
   *   }
   * })
   * 
  **/
  delete<T extends reviewDeleteArgs>(
    args: Subset<T, reviewDeleteArgs>
  ): CheckSelect<T, reviewClient<review>, reviewClient<reviewGetPayload<T>>>
  /**
   * Update one Review.
   * @param {reviewUpdateArgs} args - Arguments to update one Review.
   * @example
   * // Update one Review
   * const review = await prisma.review.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends reviewUpdateArgs>(
    args: Subset<T, reviewUpdateArgs>
  ): CheckSelect<T, reviewClient<review>, reviewClient<reviewGetPayload<T>>>
  /**
   * Delete zero or more Reviews.
   * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
   * @example
   * // Delete a few Reviews
   * const { count } = await prisma.review.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends reviewDeleteManyArgs>(
    args: Subset<T, reviewDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Reviews.
   * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Reviews
   * const review = await prisma.review.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends reviewUpdateManyArgs>(
    args: Subset<T, reviewUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Review.
   * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
   * @example
   * // Update or create a Review
   * const review = await prisma.review.upsert({
   *   create: {
   *     // ... data to create a Review
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Review we want to update
   *   }
   * })
  **/
  upsert<T extends reviewUpsertArgs>(
    args: Subset<T, reviewUpsertArgs>
  ): CheckSelect<T, reviewClient<review>, reviewClient<reviewGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyreviewArgs, 'select' | 'include'>): Promise<number>
}

export declare class reviewClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  room<T extends roomArgs = {}>(args?: Subset<T, roomArgs>): CheckSelect<T, roomClient<room | null>, roomClient<roomGetPayload<T> | null>>;

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, userClient<user | null>, userClient<userGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * review findOne
 */
export type FindOnereviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter, which review to fetch.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review findMany
 */
export type FindManyreviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter, which reviews to fetch.
  **/
  where?: reviewWhereInput | null
  /**
   * Determine the order of the reviews to fetch.
  **/
  orderBy?: reviewOrderByInput | null
  /**
   * Skip the first `n` reviews.
  **/
  skip?: number | null
  /**
   * Get all reviews that come after the review you provide with the current order.
  **/
  after?: reviewWhereUniqueInput | null
  /**
   * Get all reviews that come before the review you provide with the current order.
  **/
  before?: reviewWhereUniqueInput | null
  /**
   * Get the first `n` reviews.
  **/
  first?: number | null
  /**
   * Get the last `n` reviews.
  **/
  last?: number | null
}


/**
 * review create
 */
export type reviewCreateArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The data needed to create a review.
  **/
  data: reviewCreateInput
}


/**
 * review update
 */
export type reviewUpdateArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The data needed to update a review.
  **/
  data: reviewUpdateInput
  /**
   * Choose, which review to update.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review updateMany
 */
export type reviewUpdateManyArgs = {
  data: reviewUpdateManyMutationInput
  where?: reviewWhereInput | null
}


/**
 * review upsert
 */
export type reviewUpsertArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The filter to search for the review to update in case it exists.
  **/
  where: reviewWhereUniqueInput
  /**
   * In case the review found by the `where` argument doesn't exist, create a new review with this data.
  **/
  create: reviewCreateInput
  /**
   * In case the review was found with the provided `where` argument, update it with this data.
  **/
  update: reviewUpdateInput
}


/**
 * review delete
 */
export type reviewDeleteArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter which review to delete.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review deleteMany
 */
export type reviewDeleteManyArgs = {
  where?: reviewWhereInput | null
}


/**
 * review without action
 */
export type reviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
}



/**
 * Model room
 */

export type room = {
  address: string | null
  baths: number | null
  bedrooms: number | null
  beds: number | null
  check_in: Date | null
  check_out: Date | null
  city: string | null
  convenience: string[]
  country: string | null
  dates: string[]
  description: string | null
  guests: number | null
  houseRadio: string | null
  houseType: string | null
  id: number
  instant_book: boolean | null
  lat: number | null
  lng: number | null
  name: string
  post_code: string | null
  price: number | null
  room_type: string | null
  score: number | null
  userId: number | null
}

export type roomSelect = {
  address?: boolean
  baths?: boolean
  bedrooms?: boolean
  beds?: boolean
  check_in?: boolean
  check_out?: boolean
  city?: boolean
  convenience?: boolean
  country?: boolean
  dates?: boolean
  description?: boolean
  guests?: boolean
  houseRadio?: boolean
  houseType?: boolean
  id?: boolean
  instant_book?: boolean
  lat?: boolean
  lng?: boolean
  name?: boolean
  post_code?: boolean
  price?: boolean
  room_type?: boolean
  score?: boolean
  userId?: boolean
  user?: boolean | userArgs
  like?: boolean | FindManylikeArgs
  photo?: boolean | FindManyphotoArgs
  reservation?: boolean | FindManyreservationArgs
  review?: boolean | FindManyreviewArgs
}

export type roomInclude = {
  user?: boolean | userArgs
  like?: boolean | FindManylikeArgs
  photo?: boolean | FindManyphotoArgs
  reservation?: boolean | FindManyreservationArgs
  review?: boolean | FindManyreviewArgs
}

export type roomGetPayload<
  S extends boolean | null | undefined | roomArgs,
  U = keyof S
> = S extends true
  ? room
  : S extends undefined
  ? never
  : S extends FindManyroomArgs
  ? 'include' extends U
    ? room  & {
      [P in TrueKeys<S['include']>]:
      P extends 'user'
      ? userGetPayload<S['include'][P]> | null :
      P extends 'like'
      ? Array<likeGetPayload<S['include'][P]>> :
      P extends 'photo'
      ? Array<photoGetPayload<S['include'][P]>> :
      P extends 'reservation'
      ? Array<reservationGetPayload<S['include'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof room ? room[P]
: 
      P extends 'user'
      ? userGetPayload<S['select'][P]> | null :
      P extends 'like'
      ? Array<likeGetPayload<S['select'][P]>> :
      P extends 'photo'
      ? Array<photoGetPayload<S['select'][P]>> :
      P extends 'reservation'
      ? Array<reservationGetPayload<S['select'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['select'][P]>> : never
    }
  : room
: room


export interface roomDelegate {
  /**
   * Find zero or one Room.
   * @param {FindOneroomArgs} args - Arguments to find a Room
   * @example
   * // Get one Room
   * const room = await prisma.room.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneroomArgs>(
    args: Subset<T, FindOneroomArgs>
  ): CheckSelect<T, roomClient<room | null>, roomClient<roomGetPayload<T> | null>>
  /**
   * Find zero or more Rooms.
   * @param {FindManyroomArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Rooms
   * const rooms = await prisma.room.findMany()
   * 
   * // Get first 10 Rooms
   * const rooms = await prisma.room.findMany({ first: 10 })
   * 
   * // Only select the `address`
   * const roomWithAddressOnly = await prisma.room.findMany({ select: { address: true } })
   * 
  **/
  findMany<T extends FindManyroomArgs>(
    args?: Subset<T, FindManyroomArgs>
  ): CheckSelect<T, Promise<Array<room>>, Promise<Array<roomGetPayload<T>>>>
  /**
   * Create a Room.
   * @param {roomCreateArgs} args - Arguments to create a Room.
   * @example
   * // Create one Room
   * const user = await prisma.room.create({
   *   data: {
   *     // ... data to create a Room
   *   }
   * })
   * 
  **/
  create<T extends roomCreateArgs>(
    args: Subset<T, roomCreateArgs>
  ): CheckSelect<T, roomClient<room>, roomClient<roomGetPayload<T>>>
  /**
   * Delete a Room.
   * @param {roomDeleteArgs} args - Arguments to delete one Room.
   * @example
   * // Delete one Room
   * const user = await prisma.room.delete({
   *   where: {
   *     // ... filter to delete one Room
   *   }
   * })
   * 
  **/
  delete<T extends roomDeleteArgs>(
    args: Subset<T, roomDeleteArgs>
  ): CheckSelect<T, roomClient<room>, roomClient<roomGetPayload<T>>>
  /**
   * Update one Room.
   * @param {roomUpdateArgs} args - Arguments to update one Room.
   * @example
   * // Update one Room
   * const room = await prisma.room.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends roomUpdateArgs>(
    args: Subset<T, roomUpdateArgs>
  ): CheckSelect<T, roomClient<room>, roomClient<roomGetPayload<T>>>
  /**
   * Delete zero or more Rooms.
   * @param {roomDeleteManyArgs} args - Arguments to filter Rooms to delete.
   * @example
   * // Delete a few Rooms
   * const { count } = await prisma.room.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends roomDeleteManyArgs>(
    args: Subset<T, roomDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Rooms.
   * @param {roomUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Rooms
   * const room = await prisma.room.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends roomUpdateManyArgs>(
    args: Subset<T, roomUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Room.
   * @param {roomUpsertArgs} args - Arguments to update or create a Room.
   * @example
   * // Update or create a Room
   * const room = await prisma.room.upsert({
   *   create: {
   *     // ... data to create a Room
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Room we want to update
   *   }
   * })
  **/
  upsert<T extends roomUpsertArgs>(
    args: Subset<T, roomUpsertArgs>
  ): CheckSelect<T, roomClient<room>, roomClient<roomGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyroomArgs, 'select' | 'include'>): Promise<number>
}

export declare class roomClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, userClient<user | null>, userClient<userGetPayload<T> | null>>;

  like<T extends FindManylikeArgs = {}>(args?: Subset<T, FindManylikeArgs>): CheckSelect<T, Promise<Array<like>>, Promise<Array<likeGetPayload<T>>>>;

  photo<T extends FindManyphotoArgs = {}>(args?: Subset<T, FindManyphotoArgs>): CheckSelect<T, Promise<Array<photo>>, Promise<Array<photoGetPayload<T>>>>;

  reservation<T extends FindManyreservationArgs = {}>(args?: Subset<T, FindManyreservationArgs>): CheckSelect<T, Promise<Array<reservation>>, Promise<Array<reservationGetPayload<T>>>>;

  review<T extends FindManyreviewArgs = {}>(args?: Subset<T, FindManyreviewArgs>): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * room findOne
 */
export type FindOneroomArgs = {
  /**
   * Select specific fields to fetch from the room
  **/
  select?: roomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: roomInclude | null
  /**
   * Filter, which room to fetch.
  **/
  where: roomWhereUniqueInput
}


/**
 * room findMany
 */
export type FindManyroomArgs = {
  /**
   * Select specific fields to fetch from the room
  **/
  select?: roomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: roomInclude | null
  /**
   * Filter, which rooms to fetch.
  **/
  where?: roomWhereInput | null
  /**
   * Determine the order of the rooms to fetch.
  **/
  orderBy?: roomOrderByInput | null
  /**
   * Skip the first `n` rooms.
  **/
  skip?: number | null
  /**
   * Get all rooms that come after the room you provide with the current order.
  **/
  after?: roomWhereUniqueInput | null
  /**
   * Get all rooms that come before the room you provide with the current order.
  **/
  before?: roomWhereUniqueInput | null
  /**
   * Get the first `n` rooms.
  **/
  first?: number | null
  /**
   * Get the last `n` rooms.
  **/
  last?: number | null
}


/**
 * room create
 */
export type roomCreateArgs = {
  /**
   * Select specific fields to fetch from the room
  **/
  select?: roomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: roomInclude | null
  /**
   * The data needed to create a room.
  **/
  data: roomCreateInput
}


/**
 * room update
 */
export type roomUpdateArgs = {
  /**
   * Select specific fields to fetch from the room
  **/
  select?: roomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: roomInclude | null
  /**
   * The data needed to update a room.
  **/
  data: roomUpdateInput
  /**
   * Choose, which room to update.
  **/
  where: roomWhereUniqueInput
}


/**
 * room updateMany
 */
export type roomUpdateManyArgs = {
  data: roomUpdateManyMutationInput
  where?: roomWhereInput | null
}


/**
 * room upsert
 */
export type roomUpsertArgs = {
  /**
   * Select specific fields to fetch from the room
  **/
  select?: roomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: roomInclude | null
  /**
   * The filter to search for the room to update in case it exists.
  **/
  where: roomWhereUniqueInput
  /**
   * In case the room found by the `where` argument doesn't exist, create a new room with this data.
  **/
  create: roomCreateInput
  /**
   * In case the room was found with the provided `where` argument, update it with this data.
  **/
  update: roomUpdateInput
}


/**
 * room delete
 */
export type roomDeleteArgs = {
  /**
   * Select specific fields to fetch from the room
  **/
  select?: roomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: roomInclude | null
  /**
   * Filter which room to delete.
  **/
  where: roomWhereUniqueInput
}


/**
 * room deleteMany
 */
export type roomDeleteManyArgs = {
  where?: roomWhereInput | null
}


/**
 * room without action
 */
export type roomArgs = {
  /**
   * Select specific fields to fetch from the room
  **/
  select?: roomSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: roomInclude | null
}



/**
 * Model user
 */

export type user = {
  avatar: string | null
  birthdate: Date | null
  currentcy: string | null
  email: string
  email_secret: string | null
  email_verified: boolean | null
  gender: string | null
  id: number
  language: string | null
  login_method: string | null
  name: string | null
  password: string
  superhost: boolean | null
  tokenVersion: string | null
}

export type userSelect = {
  avatar?: boolean
  birthdate?: boolean
  currentcy?: boolean
  email?: boolean
  email_secret?: boolean
  email_verified?: boolean
  gender?: boolean
  id?: boolean
  language?: boolean
  login_method?: boolean
  name?: boolean
  password?: boolean
  superhost?: boolean
  tokenVersion?: boolean
  like?: boolean | FindManylikeArgs
  list?: boolean | listArgs
  message?: boolean | messageArgs
  reservation?: boolean | FindManyreservationArgs
  review?: boolean | FindManyreviewArgs
  room?: boolean | FindManyroomArgs
}

export type userInclude = {
  like?: boolean | FindManylikeArgs
  list?: boolean | listArgs
  message?: boolean | messageArgs
  reservation?: boolean | FindManyreservationArgs
  review?: boolean | FindManyreviewArgs
  room?: boolean | FindManyroomArgs
}

export type userGetPayload<
  S extends boolean | null | undefined | userArgs,
  U = keyof S
> = S extends true
  ? user
  : S extends undefined
  ? never
  : S extends FindManyuserArgs
  ? 'include' extends U
    ? user  & {
      [P in TrueKeys<S['include']>]:
      P extends 'like'
      ? Array<likeGetPayload<S['include'][P]>> :
      P extends 'list'
      ? listGetPayload<S['include'][P]> | null :
      P extends 'message'
      ? messageGetPayload<S['include'][P]> | null :
      P extends 'reservation'
      ? Array<reservationGetPayload<S['include'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['include'][P]>> :
      P extends 'room'
      ? Array<roomGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof user ? user[P]
: 
      P extends 'like'
      ? Array<likeGetPayload<S['select'][P]>> :
      P extends 'list'
      ? listGetPayload<S['select'][P]> | null :
      P extends 'message'
      ? messageGetPayload<S['select'][P]> | null :
      P extends 'reservation'
      ? Array<reservationGetPayload<S['select'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['select'][P]>> :
      P extends 'room'
      ? Array<roomGetPayload<S['select'][P]>> : never
    }
  : user
: user


export interface userDelegate {
  /**
   * Find zero or one User.
   * @param {FindOneuserArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneuserArgs>(
    args: Subset<T, FindOneuserArgs>
  ): CheckSelect<T, userClient<user | null>, userClient<userGetPayload<T> | null>>
  /**
   * Find zero or more Users.
   * @param {FindManyuserArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Users
   * const users = await prisma.user.findMany()
   * 
   * // Get first 10 Users
   * const users = await prisma.user.findMany({ first: 10 })
   * 
   * // Only select the `avatar`
   * const userWithAvatarOnly = await prisma.user.findMany({ select: { avatar: true } })
   * 
  **/
  findMany<T extends FindManyuserArgs>(
    args?: Subset<T, FindManyuserArgs>
  ): CheckSelect<T, Promise<Array<user>>, Promise<Array<userGetPayload<T>>>>
  /**
   * Create a User.
   * @param {userCreateArgs} args - Arguments to create a User.
   * @example
   * // Create one User
   * const user = await prisma.user.create({
   *   data: {
   *     // ... data to create a User
   *   }
   * })
   * 
  **/
  create<T extends userCreateArgs>(
    args: Subset<T, userCreateArgs>
  ): CheckSelect<T, userClient<user>, userClient<userGetPayload<T>>>
  /**
   * Delete a User.
   * @param {userDeleteArgs} args - Arguments to delete one User.
   * @example
   * // Delete one User
   * const user = await prisma.user.delete({
   *   where: {
   *     // ... filter to delete one User
   *   }
   * })
   * 
  **/
  delete<T extends userDeleteArgs>(
    args: Subset<T, userDeleteArgs>
  ): CheckSelect<T, userClient<user>, userClient<userGetPayload<T>>>
  /**
   * Update one User.
   * @param {userUpdateArgs} args - Arguments to update one User.
   * @example
   * // Update one User
   * const user = await prisma.user.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends userUpdateArgs>(
    args: Subset<T, userUpdateArgs>
  ): CheckSelect<T, userClient<user>, userClient<userGetPayload<T>>>
  /**
   * Delete zero or more Users.
   * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
   * @example
   * // Delete a few Users
   * const { count } = await prisma.user.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends userDeleteManyArgs>(
    args: Subset<T, userDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Users.
   * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Users
   * const user = await prisma.user.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends userUpdateManyArgs>(
    args: Subset<T, userUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one User.
   * @param {userUpsertArgs} args - Arguments to update or create a User.
   * @example
   * // Update or create a User
   * const user = await prisma.user.upsert({
   *   create: {
   *     // ... data to create a User
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the User we want to update
   *   }
   * })
  **/
  upsert<T extends userUpsertArgs>(
    args: Subset<T, userUpsertArgs>
  ): CheckSelect<T, userClient<user>, userClient<userGetPayload<T>>>
  /**
   * 
   */
  count(args?: Omit<FindManyuserArgs, 'select' | 'include'>): Promise<number>
}

export declare class userClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  like<T extends FindManylikeArgs = {}>(args?: Subset<T, FindManylikeArgs>): CheckSelect<T, Promise<Array<like>>, Promise<Array<likeGetPayload<T>>>>;

  list<T extends listArgs = {}>(args?: Subset<T, listArgs>): CheckSelect<T, listClient<list | null>, listClient<listGetPayload<T> | null>>;

  message<T extends messageArgs = {}>(args?: Subset<T, messageArgs>): CheckSelect<T, messageClient<message | null>, messageClient<messageGetPayload<T> | null>>;

  reservation<T extends FindManyreservationArgs = {}>(args?: Subset<T, FindManyreservationArgs>): CheckSelect<T, Promise<Array<reservation>>, Promise<Array<reservationGetPayload<T>>>>;

  review<T extends FindManyreviewArgs = {}>(args?: Subset<T, FindManyreviewArgs>): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>;

  room<T extends FindManyroomArgs = {}>(args?: Subset<T, FindManyroomArgs>): CheckSelect<T, Promise<Array<room>>, Promise<Array<roomGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * user findOne
 */
export type FindOneuserArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * Filter, which user to fetch.
  **/
  where: userWhereUniqueInput
}


/**
 * user findMany
 */
export type FindManyuserArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * Filter, which users to fetch.
  **/
  where?: userWhereInput | null
  /**
   * Determine the order of the users to fetch.
  **/
  orderBy?: userOrderByInput | null
  /**
   * Skip the first `n` users.
  **/
  skip?: number | null
  /**
   * Get all users that come after the user you provide with the current order.
  **/
  after?: userWhereUniqueInput | null
  /**
   * Get all users that come before the user you provide with the current order.
  **/
  before?: userWhereUniqueInput | null
  /**
   * Get the first `n` users.
  **/
  first?: number | null
  /**
   * Get the last `n` users.
  **/
  last?: number | null
}


/**
 * user create
 */
export type userCreateArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * The data needed to create a user.
  **/
  data: userCreateInput
}


/**
 * user update
 */
export type userUpdateArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * The data needed to update a user.
  **/
  data: userUpdateInput
  /**
   * Choose, which user to update.
  **/
  where: userWhereUniqueInput
}


/**
 * user updateMany
 */
export type userUpdateManyArgs = {
  data: userUpdateManyMutationInput
  where?: userWhereInput | null
}


/**
 * user upsert
 */
export type userUpsertArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * The filter to search for the user to update in case it exists.
  **/
  where: userWhereUniqueInput
  /**
   * In case the user found by the `where` argument doesn't exist, create a new user with this data.
  **/
  create: userCreateInput
  /**
   * In case the user was found with the provided `where` argument, update it with this data.
  **/
  update: userUpdateInput
}


/**
 * user delete
 */
export type userDeleteArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * Filter which user to delete.
  **/
  where: userWhereUniqueInput
}


/**
 * user deleteMany
 */
export type userDeleteManyArgs = {
  where?: userWhereInput | null
}


/**
 * user without action
 */
export type userArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
}



/**
 * Deep Input Types
 */


export type photoWhereInput = {
  caption?: string | NullableStringFilter | null
  file?: string | NullableStringFilter | null
  hostId?: number | NullableIntFilter | null
  id?: number | IntFilter | null
  roomId?: number | NullableIntFilter | null
  AND?: Enumerable<photoWhereInput> | null
  OR?: Enumerable<photoWhereInput> | null
  NOT?: Enumerable<photoWhereInput> | null
  room?: roomWhereInput | null
}

export type reservationWhereInput = {
  check_in?: Date | string | NullableDateTimeFilter | null
  check_out?: Date | string | NullableDateTimeFilter | null
  guestId?: number | IntFilter | null
  id?: number | IntFilter | null
  in_progress?: boolean | NullableBooleanFilter | null
  is_finished?: boolean | NullableBooleanFilter | null
  roomId?: number | IntFilter | null
  AND?: Enumerable<reservationWhereInput> | null
  OR?: Enumerable<reservationWhereInput> | null
  NOT?: Enumerable<reservationWhereInput> | null
  user?: userWhereInput | null
  room?: roomWhereInput | null
}

export type reviewWhereInput = {
  accuracy?: number | NullableIntFilter | null
  check_in?: number | NullableIntFilter | null
  cleanliness?: number | NullableIntFilter | null
  communication?: number | NullableIntFilter | null
  createdAt?: string | NullableStringFilter | null
  id?: number | IntFilter | null
  location?: number | NullableIntFilter | null
  review?: string | NullableStringFilter | null
  roomId?: number | IntFilter | null
  userId?: number | NullableIntFilter | null
  value?: number | NullableIntFilter | null
  AND?: Enumerable<reviewWhereInput> | null
  OR?: Enumerable<reviewWhereInput> | null
  NOT?: Enumerable<reviewWhereInput> | null
  room?: roomWhereInput | null
  user?: userWhereInput | null
}

export type roomWhereInput = {
  address?: string | NullableStringFilter | null
  baths?: number | NullableIntFilter | null
  bedrooms?: number | NullableIntFilter | null
  beds?: number | NullableIntFilter | null
  check_in?: Date | string | NullableDateTimeFilter | null
  check_out?: Date | string | NullableDateTimeFilter | null
  city?: string | NullableStringFilter | null
  country?: string | NullableStringFilter | null
  description?: string | NullableStringFilter | null
  guests?: number | NullableIntFilter | null
  houseRadio?: string | NullableStringFilter | null
  houseType?: string | NullableStringFilter | null
  id?: number | IntFilter | null
  instant_book?: boolean | NullableBooleanFilter | null
  lat?: number | NullableFloatFilter | null
  lng?: number | NullableFloatFilter | null
  name?: string | StringFilter | null
  post_code?: string | NullableStringFilter | null
  price?: number | NullableIntFilter | null
  room_type?: string | NullableStringFilter | null
  score?: number | NullableIntFilter | null
  userId?: number | NullableIntFilter | null
  like?: likeFilter | null
  photo?: photoFilter | null
  reservation?: reservationFilter | null
  review?: reviewFilter | null
  AND?: Enumerable<roomWhereInput> | null
  OR?: Enumerable<roomWhereInput> | null
  NOT?: Enumerable<roomWhereInput> | null
  user?: userWhereInput | null
}

export type likeWhereInput = {
  id?: number | IntFilter | null
  roomId?: number | IntFilter | null
  userId?: number | IntFilter | null
  AND?: Enumerable<likeWhereInput> | null
  OR?: Enumerable<likeWhereInput> | null
  NOT?: Enumerable<likeWhereInput> | null
  room?: roomWhereInput | null
  user?: userWhereInput | null
}

export type listWhereInput = {
  id?: number | IntFilter | null
  name?: string | StringFilter | null
  userId?: number | NullableIntFilter | null
  AND?: Enumerable<listWhereInput> | null
  OR?: Enumerable<listWhereInput> | null
  NOT?: Enumerable<listWhereInput> | null
  user?: userWhereInput | null
}

export type userWhereInput = {
  avatar?: string | NullableStringFilter | null
  birthdate?: Date | string | NullableDateTimeFilter | null
  currentcy?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  email_secret?: string | NullableStringFilter | null
  email_verified?: boolean | NullableBooleanFilter | null
  gender?: string | NullableStringFilter | null
  id?: number | IntFilter | null
  language?: string | NullableStringFilter | null
  login_method?: string | NullableStringFilter | null
  name?: string | NullableStringFilter | null
  password?: string | StringFilter | null
  superhost?: boolean | NullableBooleanFilter | null
  tokenVersion?: string | NullableStringFilter | null
  like?: likeFilter | null
  reservation?: reservationFilter | null
  review?: reviewFilter | null
  room?: roomFilter | null
  AND?: Enumerable<userWhereInput> | null
  OR?: Enumerable<userWhereInput> | null
  NOT?: Enumerable<userWhereInput> | null
  list?: listWhereInput | null
  message?: messageWhereInput | null
}

export type messageWhereInput = {
  conversationId?: number | NullableIntFilter | null
  id?: number | IntFilter | null
  message?: string | StringFilter | null
  userId?: number | NullableIntFilter | null
  AND?: Enumerable<messageWhereInput> | null
  OR?: Enumerable<messageWhereInput> | null
  NOT?: Enumerable<messageWhereInput> | null
  conversation?: conversationWhereInput | null
  user?: userWhereInput | null
}

export type conversationWhereInput = {
  id?: number | IntFilter | null
  AND?: Enumerable<conversationWhereInput> | null
  OR?: Enumerable<conversationWhereInput> | null
  NOT?: Enumerable<conversationWhereInput> | null
  message?: messageWhereInput | null
}

export type conversationWhereUniqueInput = {
  id?: number | null
}

export type likeWhereUniqueInput = {
  id?: number | null
}

export type photoWhereUniqueInput = {
  id?: number | null
}

export type reservationWhereUniqueInput = {
  id?: number | null
}

export type reviewWhereUniqueInput = {
  id?: number | null
}

export type roomWhereUniqueInput = {
  id?: number | null
}

export type listWhereUniqueInput = {
  id?: number | null
  userId?: number | null
}

export type messageWhereUniqueInput = {
  conversationId?: number | null
  id?: number | null
  userId?: number | null
}

export type movieWhereInput = {
  id?: number | IntFilter | null
  minutes?: number | IntFilter | null
  title?: string | StringFilter | null
  AND?: Enumerable<movieWhereInput> | null
  OR?: Enumerable<movieWhereInput> | null
  NOT?: Enumerable<movieWhereInput> | null
}

export type movieWhereUniqueInput = {
  id?: number | null
}

export type userWhereUniqueInput = {
  id?: number | null
}

export type roomCreateconvenienceInput = {
  set?: Enumerable<string> | null
}

export type roomCreatedatesInput = {
  set?: Enumerable<string> | null
}

export type listCreateWithoutUserInput = {
  name: string
}

export type listCreateOneWithoutUserInput = {
  create?: listCreateWithoutUserInput | null
  connect?: listWhereUniqueInput | null
}

export type conversationCreateWithoutMessageInput = {

}

export type conversationCreateOneWithoutMessageInput = {
  create?: conversationCreateWithoutMessageInput | null
  connect?: conversationWhereUniqueInput | null
}

export type messageCreateWithoutUserInput = {
  message: string
  conversation?: conversationCreateOneWithoutMessageInput | null
}

export type messageCreateOneWithoutUserInput = {
  create?: messageCreateWithoutUserInput | null
  connect?: messageWhereUniqueInput | null
}

export type photoCreateWithoutRoomInput = {
  caption?: string | null
  file?: string | null
  hostId?: number | null
}

export type photoCreateManyWithoutRoomInput = {
  create?: Enumerable<photoCreateWithoutRoomInput> | null
  connect?: Enumerable<photoWhereUniqueInput> | null
}

export type userCreateWithoutReviewInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email: string
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password: string
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeCreateManyWithoutUserInput | null
  list?: listCreateOneWithoutUserInput | null
  message?: messageCreateOneWithoutUserInput | null
  reservation?: reservationCreateManyWithoutUserInput | null
  room?: roomCreateManyWithoutUserInput | null
}

export type userCreateOneWithoutReviewInput = {
  create?: userCreateWithoutReviewInput | null
  connect?: userWhereUniqueInput | null
}

export type reviewCreateWithoutRoomInput = {
  accuracy?: number | null
  check_in?: number | null
  cleanliness?: number | null
  communication?: number | null
  createdAt?: string | null
  location?: number | null
  review?: string | null
  value?: number | null
  user?: userCreateOneWithoutReviewInput | null
}

export type reviewCreateManyWithoutRoomInput = {
  create?: Enumerable<reviewCreateWithoutRoomInput> | null
  connect?: Enumerable<reviewWhereUniqueInput> | null
}

export type roomCreateWithoutUserInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name: string
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomCreateconvenienceInput | null
  dates?: roomCreatedatesInput | null
  like?: likeCreateManyWithoutRoomInput | null
  photo?: photoCreateManyWithoutRoomInput | null
  reservation?: reservationCreateManyWithoutRoomInput | null
  review?: reviewCreateManyWithoutRoomInput | null
}

export type roomCreateManyWithoutUserInput = {
  create?: Enumerable<roomCreateWithoutUserInput> | null
  connect?: Enumerable<roomWhereUniqueInput> | null
}

export type userCreateWithoutReservationInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email: string
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password: string
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeCreateManyWithoutUserInput | null
  list?: listCreateOneWithoutUserInput | null
  message?: messageCreateOneWithoutUserInput | null
  review?: reviewCreateManyWithoutUserInput | null
  room?: roomCreateManyWithoutUserInput | null
}

export type userCreateOneWithoutReservationInput = {
  create?: userCreateWithoutReservationInput | null
  connect?: userWhereUniqueInput | null
}

export type reservationCreateWithoutRoomInput = {
  check_in?: Date | string | null
  check_out?: Date | string | null
  in_progress?: boolean | null
  is_finished?: boolean | null
  user: userCreateOneWithoutReservationInput
}

export type reservationCreateManyWithoutRoomInput = {
  create?: Enumerable<reservationCreateWithoutRoomInput> | null
  connect?: Enumerable<reservationWhereUniqueInput> | null
}

export type roomCreateWithoutReviewInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name: string
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomCreateconvenienceInput | null
  dates?: roomCreatedatesInput | null
  user?: userCreateOneWithoutRoomInput | null
  like?: likeCreateManyWithoutRoomInput | null
  photo?: photoCreateManyWithoutRoomInput | null
  reservation?: reservationCreateManyWithoutRoomInput | null
}

export type roomCreateOneWithoutReviewInput = {
  create?: roomCreateWithoutReviewInput | null
  connect?: roomWhereUniqueInput | null
}

export type reviewCreateWithoutUserInput = {
  accuracy?: number | null
  check_in?: number | null
  cleanliness?: number | null
  communication?: number | null
  createdAt?: string | null
  location?: number | null
  review?: string | null
  value?: number | null
  room: roomCreateOneWithoutReviewInput
}

export type reviewCreateManyWithoutUserInput = {
  create?: Enumerable<reviewCreateWithoutUserInput> | null
  connect?: Enumerable<reviewWhereUniqueInput> | null
}

export type userCreateWithoutLikeInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email: string
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password: string
  superhost?: boolean | null
  tokenVersion?: string | null
  list?: listCreateOneWithoutUserInput | null
  message?: messageCreateOneWithoutUserInput | null
  reservation?: reservationCreateManyWithoutUserInput | null
  review?: reviewCreateManyWithoutUserInput | null
  room?: roomCreateManyWithoutUserInput | null
}

export type userCreateOneWithoutLikeInput = {
  create?: userCreateWithoutLikeInput | null
  connect?: userWhereUniqueInput | null
}

export type likeCreateWithoutRoomInput = {
  user: userCreateOneWithoutLikeInput
}

export type likeCreateManyWithoutRoomInput = {
  create?: Enumerable<likeCreateWithoutRoomInput> | null
  connect?: Enumerable<likeWhereUniqueInput> | null
}

export type roomCreateWithoutReservationInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name: string
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomCreateconvenienceInput | null
  dates?: roomCreatedatesInput | null
  user?: userCreateOneWithoutRoomInput | null
  like?: likeCreateManyWithoutRoomInput | null
  photo?: photoCreateManyWithoutRoomInput | null
  review?: reviewCreateManyWithoutRoomInput | null
}

export type roomCreateOneWithoutReservationInput = {
  create?: roomCreateWithoutReservationInput | null
  connect?: roomWhereUniqueInput | null
}

export type reservationCreateWithoutUserInput = {
  check_in?: Date | string | null
  check_out?: Date | string | null
  in_progress?: boolean | null
  is_finished?: boolean | null
  room: roomCreateOneWithoutReservationInput
}

export type reservationCreateManyWithoutUserInput = {
  create?: Enumerable<reservationCreateWithoutUserInput> | null
  connect?: Enumerable<reservationWhereUniqueInput> | null
}

export type userCreateWithoutRoomInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email: string
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password: string
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeCreateManyWithoutUserInput | null
  list?: listCreateOneWithoutUserInput | null
  message?: messageCreateOneWithoutUserInput | null
  reservation?: reservationCreateManyWithoutUserInput | null
  review?: reviewCreateManyWithoutUserInput | null
}

export type userCreateOneWithoutRoomInput = {
  create?: userCreateWithoutRoomInput | null
  connect?: userWhereUniqueInput | null
}

export type roomCreateWithoutLikeInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name: string
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomCreateconvenienceInput | null
  dates?: roomCreatedatesInput | null
  user?: userCreateOneWithoutRoomInput | null
  photo?: photoCreateManyWithoutRoomInput | null
  reservation?: reservationCreateManyWithoutRoomInput | null
  review?: reviewCreateManyWithoutRoomInput | null
}

export type roomCreateOneWithoutLikeInput = {
  create?: roomCreateWithoutLikeInput | null
  connect?: roomWhereUniqueInput | null
}

export type likeCreateWithoutUserInput = {
  room: roomCreateOneWithoutLikeInput
}

export type likeCreateManyWithoutUserInput = {
  create?: Enumerable<likeCreateWithoutUserInput> | null
  connect?: Enumerable<likeWhereUniqueInput> | null
}

export type userCreateWithoutMessageInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email: string
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password: string
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeCreateManyWithoutUserInput | null
  list?: listCreateOneWithoutUserInput | null
  reservation?: reservationCreateManyWithoutUserInput | null
  review?: reviewCreateManyWithoutUserInput | null
  room?: roomCreateManyWithoutUserInput | null
}

export type userCreateOneWithoutMessageInput = {
  create?: userCreateWithoutMessageInput | null
  connect?: userWhereUniqueInput | null
}

export type messageCreateWithoutConversationInput = {
  message: string
  user?: userCreateOneWithoutMessageInput | null
}

export type messageCreateOneWithoutConversationInput = {
  create?: messageCreateWithoutConversationInput | null
  connect?: messageWhereUniqueInput | null
}

export type conversationCreateInput = {
  message?: messageCreateOneWithoutConversationInput | null
}

export type roomUpdateconvenienceInput = {
  set?: Enumerable<string> | null
}

export type roomUpdatedatesInput = {
  set?: Enumerable<string> | null
}

export type listUpdateWithoutUserDataInput = {
  id?: number | null
  name?: string | null
}

export type listUpsertWithoutUserInput = {
  update: listUpdateWithoutUserDataInput
  create: listCreateWithoutUserInput
}

export type listUpdateOneWithoutUserInput = {
  create?: listCreateWithoutUserInput | null
  connect?: listWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: listUpdateWithoutUserDataInput | null
  upsert?: listUpsertWithoutUserInput | null
}

export type conversationUpdateWithoutMessageDataInput = {
  id?: number | null
}

export type conversationUpdateOneWithoutMessageInput = {
  create?: conversationCreateWithoutMessageInput | null
  connect?: conversationWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: conversationUpdateWithoutMessageDataInput | null
}

export type messageUpdateWithoutUserDataInput = {
  id?: number | null
  message?: string | null
  conversation?: conversationUpdateOneWithoutMessageInput | null
}

export type messageUpsertWithoutUserInput = {
  update: messageUpdateWithoutUserDataInput
  create: messageCreateWithoutUserInput
}

export type messageUpdateOneWithoutUserInput = {
  create?: messageCreateWithoutUserInput | null
  connect?: messageWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: messageUpdateWithoutUserDataInput | null
  upsert?: messageUpsertWithoutUserInput | null
}

export type photoUpdateWithoutRoomDataInput = {
  caption?: string | null
  file?: string | null
  hostId?: number | null
  id?: number | null
}

export type photoUpdateWithWhereUniqueWithoutRoomInput = {
  where: photoWhereUniqueInput
  data: photoUpdateWithoutRoomDataInput
}

export type photoScalarWhereInput = {
  caption?: string | NullableStringFilter | null
  file?: string | NullableStringFilter | null
  hostId?: number | NullableIntFilter | null
  id?: number | IntFilter | null
  roomId?: number | NullableIntFilter | null
  AND?: Enumerable<photoScalarWhereInput> | null
  OR?: Enumerable<photoScalarWhereInput> | null
  NOT?: Enumerable<photoScalarWhereInput> | null
}

export type photoUpdateManyDataInput = {
  caption?: string | null
  file?: string | null
  hostId?: number | null
  id?: number | null
}

export type photoUpdateManyWithWhereNestedInput = {
  where: photoScalarWhereInput
  data: photoUpdateManyDataInput
}

export type photoUpsertWithWhereUniqueWithoutRoomInput = {
  where: photoWhereUniqueInput
  update: photoUpdateWithoutRoomDataInput
  create: photoCreateWithoutRoomInput
}

export type photoUpdateManyWithoutRoomInput = {
  create?: Enumerable<photoCreateWithoutRoomInput> | null
  connect?: Enumerable<photoWhereUniqueInput> | null
  set?: Enumerable<photoWhereUniqueInput> | null
  disconnect?: Enumerable<photoWhereUniqueInput> | null
  delete?: Enumerable<photoWhereUniqueInput> | null
  update?: Enumerable<photoUpdateWithWhereUniqueWithoutRoomInput> | null
  updateMany?: Enumerable<photoUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<photoScalarWhereInput> | null
  upsert?: Enumerable<photoUpsertWithWhereUniqueWithoutRoomInput> | null
}

export type userUpdateWithoutReviewDataInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email?: string | null
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  id?: number | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password?: string | null
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeUpdateManyWithoutUserInput | null
  list?: listUpdateOneWithoutUserInput | null
  message?: messageUpdateOneWithoutUserInput | null
  reservation?: reservationUpdateManyWithoutUserInput | null
  room?: roomUpdateManyWithoutUserInput | null
}

export type userUpsertWithoutReviewInput = {
  update: userUpdateWithoutReviewDataInput
  create: userCreateWithoutReviewInput
}

export type userUpdateOneWithoutReviewInput = {
  create?: userCreateWithoutReviewInput | null
  connect?: userWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: userUpdateWithoutReviewDataInput | null
  upsert?: userUpsertWithoutReviewInput | null
}

export type reviewUpdateWithoutRoomDataInput = {
  accuracy?: number | null
  check_in?: number | null
  cleanliness?: number | null
  communication?: number | null
  createdAt?: string | null
  id?: number | null
  location?: number | null
  review?: string | null
  value?: number | null
  user?: userUpdateOneWithoutReviewInput | null
}

export type reviewUpdateWithWhereUniqueWithoutRoomInput = {
  where: reviewWhereUniqueInput
  data: reviewUpdateWithoutRoomDataInput
}

export type reviewScalarWhereInput = {
  accuracy?: number | NullableIntFilter | null
  check_in?: number | NullableIntFilter | null
  cleanliness?: number | NullableIntFilter | null
  communication?: number | NullableIntFilter | null
  createdAt?: string | NullableStringFilter | null
  id?: number | IntFilter | null
  location?: number | NullableIntFilter | null
  review?: string | NullableStringFilter | null
  roomId?: number | IntFilter | null
  userId?: number | NullableIntFilter | null
  value?: number | NullableIntFilter | null
  AND?: Enumerable<reviewScalarWhereInput> | null
  OR?: Enumerable<reviewScalarWhereInput> | null
  NOT?: Enumerable<reviewScalarWhereInput> | null
}

export type reviewUpdateManyDataInput = {
  accuracy?: number | null
  check_in?: number | null
  cleanliness?: number | null
  communication?: number | null
  createdAt?: string | null
  id?: number | null
  location?: number | null
  review?: string | null
  value?: number | null
}

export type reviewUpdateManyWithWhereNestedInput = {
  where: reviewScalarWhereInput
  data: reviewUpdateManyDataInput
}

export type reviewUpsertWithWhereUniqueWithoutRoomInput = {
  where: reviewWhereUniqueInput
  update: reviewUpdateWithoutRoomDataInput
  create: reviewCreateWithoutRoomInput
}

export type reviewUpdateManyWithoutRoomInput = {
  create?: Enumerable<reviewCreateWithoutRoomInput> | null
  connect?: Enumerable<reviewWhereUniqueInput> | null
  set?: Enumerable<reviewWhereUniqueInput> | null
  disconnect?: Enumerable<reviewWhereUniqueInput> | null
  delete?: Enumerable<reviewWhereUniqueInput> | null
  update?: Enumerable<reviewUpdateWithWhereUniqueWithoutRoomInput> | null
  updateMany?: Enumerable<reviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<reviewScalarWhereInput> | null
  upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutRoomInput> | null
}

export type roomUpdateWithoutUserDataInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  id?: number | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name?: string | null
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomUpdateconvenienceInput | null
  dates?: roomUpdatedatesInput | null
  like?: likeUpdateManyWithoutRoomInput | null
  photo?: photoUpdateManyWithoutRoomInput | null
  reservation?: reservationUpdateManyWithoutRoomInput | null
  review?: reviewUpdateManyWithoutRoomInput | null
}

export type roomUpdateWithWhereUniqueWithoutUserInput = {
  where: roomWhereUniqueInput
  data: roomUpdateWithoutUserDataInput
}

export type roomScalarWhereInput = {
  address?: string | NullableStringFilter | null
  baths?: number | NullableIntFilter | null
  bedrooms?: number | NullableIntFilter | null
  beds?: number | NullableIntFilter | null
  check_in?: Date | string | NullableDateTimeFilter | null
  check_out?: Date | string | NullableDateTimeFilter | null
  city?: string | NullableStringFilter | null
  country?: string | NullableStringFilter | null
  description?: string | NullableStringFilter | null
  guests?: number | NullableIntFilter | null
  houseRadio?: string | NullableStringFilter | null
  houseType?: string | NullableStringFilter | null
  id?: number | IntFilter | null
  instant_book?: boolean | NullableBooleanFilter | null
  lat?: number | NullableFloatFilter | null
  lng?: number | NullableFloatFilter | null
  name?: string | StringFilter | null
  post_code?: string | NullableStringFilter | null
  price?: number | NullableIntFilter | null
  room_type?: string | NullableStringFilter | null
  score?: number | NullableIntFilter | null
  userId?: number | NullableIntFilter | null
  like?: likeFilter | null
  photo?: photoFilter | null
  reservation?: reservationFilter | null
  review?: reviewFilter | null
  AND?: Enumerable<roomScalarWhereInput> | null
  OR?: Enumerable<roomScalarWhereInput> | null
  NOT?: Enumerable<roomScalarWhereInput> | null
}

export type roomUpdateManyDataInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  id?: number | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name?: string | null
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomUpdateconvenienceInput | null
  dates?: roomUpdatedatesInput | null
}

export type roomUpdateManyWithWhereNestedInput = {
  where: roomScalarWhereInput
  data: roomUpdateManyDataInput
}

export type roomUpsertWithWhereUniqueWithoutUserInput = {
  where: roomWhereUniqueInput
  update: roomUpdateWithoutUserDataInput
  create: roomCreateWithoutUserInput
}

export type roomUpdateManyWithoutUserInput = {
  create?: Enumerable<roomCreateWithoutUserInput> | null
  connect?: Enumerable<roomWhereUniqueInput> | null
  set?: Enumerable<roomWhereUniqueInput> | null
  disconnect?: Enumerable<roomWhereUniqueInput> | null
  delete?: Enumerable<roomWhereUniqueInput> | null
  update?: Enumerable<roomUpdateWithWhereUniqueWithoutUserInput> | null
  updateMany?: Enumerable<roomUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<roomScalarWhereInput> | null
  upsert?: Enumerable<roomUpsertWithWhereUniqueWithoutUserInput> | null
}

export type userUpdateWithoutReservationDataInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email?: string | null
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  id?: number | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password?: string | null
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeUpdateManyWithoutUserInput | null
  list?: listUpdateOneWithoutUserInput | null
  message?: messageUpdateOneWithoutUserInput | null
  review?: reviewUpdateManyWithoutUserInput | null
  room?: roomUpdateManyWithoutUserInput | null
}

export type userUpsertWithoutReservationInput = {
  update: userUpdateWithoutReservationDataInput
  create: userCreateWithoutReservationInput
}

export type userUpdateOneRequiredWithoutReservationInput = {
  create?: userCreateWithoutReservationInput | null
  connect?: userWhereUniqueInput | null
  update?: userUpdateWithoutReservationDataInput | null
  upsert?: userUpsertWithoutReservationInput | null
}

export type reservationUpdateWithoutRoomDataInput = {
  check_in?: Date | string | null
  check_out?: Date | string | null
  id?: number | null
  in_progress?: boolean | null
  is_finished?: boolean | null
  user?: userUpdateOneRequiredWithoutReservationInput | null
}

export type reservationUpdateWithWhereUniqueWithoutRoomInput = {
  where: reservationWhereUniqueInput
  data: reservationUpdateWithoutRoomDataInput
}

export type reservationScalarWhereInput = {
  check_in?: Date | string | NullableDateTimeFilter | null
  check_out?: Date | string | NullableDateTimeFilter | null
  guestId?: number | IntFilter | null
  id?: number | IntFilter | null
  in_progress?: boolean | NullableBooleanFilter | null
  is_finished?: boolean | NullableBooleanFilter | null
  roomId?: number | IntFilter | null
  AND?: Enumerable<reservationScalarWhereInput> | null
  OR?: Enumerable<reservationScalarWhereInput> | null
  NOT?: Enumerable<reservationScalarWhereInput> | null
}

export type reservationUpdateManyDataInput = {
  check_in?: Date | string | null
  check_out?: Date | string | null
  id?: number | null
  in_progress?: boolean | null
  is_finished?: boolean | null
}

export type reservationUpdateManyWithWhereNestedInput = {
  where: reservationScalarWhereInput
  data: reservationUpdateManyDataInput
}

export type reservationUpsertWithWhereUniqueWithoutRoomInput = {
  where: reservationWhereUniqueInput
  update: reservationUpdateWithoutRoomDataInput
  create: reservationCreateWithoutRoomInput
}

export type reservationUpdateManyWithoutRoomInput = {
  create?: Enumerable<reservationCreateWithoutRoomInput> | null
  connect?: Enumerable<reservationWhereUniqueInput> | null
  set?: Enumerable<reservationWhereUniqueInput> | null
  disconnect?: Enumerable<reservationWhereUniqueInput> | null
  delete?: Enumerable<reservationWhereUniqueInput> | null
  update?: Enumerable<reservationUpdateWithWhereUniqueWithoutRoomInput> | null
  updateMany?: Enumerable<reservationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<reservationScalarWhereInput> | null
  upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutRoomInput> | null
}

export type roomUpdateWithoutReviewDataInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  id?: number | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name?: string | null
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomUpdateconvenienceInput | null
  dates?: roomUpdatedatesInput | null
  user?: userUpdateOneWithoutRoomInput | null
  like?: likeUpdateManyWithoutRoomInput | null
  photo?: photoUpdateManyWithoutRoomInput | null
  reservation?: reservationUpdateManyWithoutRoomInput | null
}

export type roomUpsertWithoutReviewInput = {
  update: roomUpdateWithoutReviewDataInput
  create: roomCreateWithoutReviewInput
}

export type roomUpdateOneRequiredWithoutReviewInput = {
  create?: roomCreateWithoutReviewInput | null
  connect?: roomWhereUniqueInput | null
  update?: roomUpdateWithoutReviewDataInput | null
  upsert?: roomUpsertWithoutReviewInput | null
}

export type reviewUpdateWithoutUserDataInput = {
  accuracy?: number | null
  check_in?: number | null
  cleanliness?: number | null
  communication?: number | null
  createdAt?: string | null
  id?: number | null
  location?: number | null
  review?: string | null
  value?: number | null
  room?: roomUpdateOneRequiredWithoutReviewInput | null
}

export type reviewUpdateWithWhereUniqueWithoutUserInput = {
  where: reviewWhereUniqueInput
  data: reviewUpdateWithoutUserDataInput
}

export type reviewUpsertWithWhereUniqueWithoutUserInput = {
  where: reviewWhereUniqueInput
  update: reviewUpdateWithoutUserDataInput
  create: reviewCreateWithoutUserInput
}

export type reviewUpdateManyWithoutUserInput = {
  create?: Enumerable<reviewCreateWithoutUserInput> | null
  connect?: Enumerable<reviewWhereUniqueInput> | null
  set?: Enumerable<reviewWhereUniqueInput> | null
  disconnect?: Enumerable<reviewWhereUniqueInput> | null
  delete?: Enumerable<reviewWhereUniqueInput> | null
  update?: Enumerable<reviewUpdateWithWhereUniqueWithoutUserInput> | null
  updateMany?: Enumerable<reviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<reviewScalarWhereInput> | null
  upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutUserInput> | null
}

export type userUpdateWithoutLikeDataInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email?: string | null
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  id?: number | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password?: string | null
  superhost?: boolean | null
  tokenVersion?: string | null
  list?: listUpdateOneWithoutUserInput | null
  message?: messageUpdateOneWithoutUserInput | null
  reservation?: reservationUpdateManyWithoutUserInput | null
  review?: reviewUpdateManyWithoutUserInput | null
  room?: roomUpdateManyWithoutUserInput | null
}

export type userUpsertWithoutLikeInput = {
  update: userUpdateWithoutLikeDataInput
  create: userCreateWithoutLikeInput
}

export type userUpdateOneRequiredWithoutLikeInput = {
  create?: userCreateWithoutLikeInput | null
  connect?: userWhereUniqueInput | null
  update?: userUpdateWithoutLikeDataInput | null
  upsert?: userUpsertWithoutLikeInput | null
}

export type likeUpdateWithoutRoomDataInput = {
  id?: number | null
  user?: userUpdateOneRequiredWithoutLikeInput | null
}

export type likeUpdateWithWhereUniqueWithoutRoomInput = {
  where: likeWhereUniqueInput
  data: likeUpdateWithoutRoomDataInput
}

export type likeScalarWhereInput = {
  id?: number | IntFilter | null
  roomId?: number | IntFilter | null
  userId?: number | IntFilter | null
  AND?: Enumerable<likeScalarWhereInput> | null
  OR?: Enumerable<likeScalarWhereInput> | null
  NOT?: Enumerable<likeScalarWhereInput> | null
}

export type likeUpdateManyDataInput = {
  id?: number | null
}

export type likeUpdateManyWithWhereNestedInput = {
  where: likeScalarWhereInput
  data: likeUpdateManyDataInput
}

export type likeUpsertWithWhereUniqueWithoutRoomInput = {
  where: likeWhereUniqueInput
  update: likeUpdateWithoutRoomDataInput
  create: likeCreateWithoutRoomInput
}

export type likeUpdateManyWithoutRoomInput = {
  create?: Enumerable<likeCreateWithoutRoomInput> | null
  connect?: Enumerable<likeWhereUniqueInput> | null
  set?: Enumerable<likeWhereUniqueInput> | null
  disconnect?: Enumerable<likeWhereUniqueInput> | null
  delete?: Enumerable<likeWhereUniqueInput> | null
  update?: Enumerable<likeUpdateWithWhereUniqueWithoutRoomInput> | null
  updateMany?: Enumerable<likeUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<likeScalarWhereInput> | null
  upsert?: Enumerable<likeUpsertWithWhereUniqueWithoutRoomInput> | null
}

export type roomUpdateWithoutReservationDataInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  id?: number | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name?: string | null
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomUpdateconvenienceInput | null
  dates?: roomUpdatedatesInput | null
  user?: userUpdateOneWithoutRoomInput | null
  like?: likeUpdateManyWithoutRoomInput | null
  photo?: photoUpdateManyWithoutRoomInput | null
  review?: reviewUpdateManyWithoutRoomInput | null
}

export type roomUpsertWithoutReservationInput = {
  update: roomUpdateWithoutReservationDataInput
  create: roomCreateWithoutReservationInput
}

export type roomUpdateOneRequiredWithoutReservationInput = {
  create?: roomCreateWithoutReservationInput | null
  connect?: roomWhereUniqueInput | null
  update?: roomUpdateWithoutReservationDataInput | null
  upsert?: roomUpsertWithoutReservationInput | null
}

export type reservationUpdateWithoutUserDataInput = {
  check_in?: Date | string | null
  check_out?: Date | string | null
  id?: number | null
  in_progress?: boolean | null
  is_finished?: boolean | null
  room?: roomUpdateOneRequiredWithoutReservationInput | null
}

export type reservationUpdateWithWhereUniqueWithoutUserInput = {
  where: reservationWhereUniqueInput
  data: reservationUpdateWithoutUserDataInput
}

export type reservationUpsertWithWhereUniqueWithoutUserInput = {
  where: reservationWhereUniqueInput
  update: reservationUpdateWithoutUserDataInput
  create: reservationCreateWithoutUserInput
}

export type reservationUpdateManyWithoutUserInput = {
  create?: Enumerable<reservationCreateWithoutUserInput> | null
  connect?: Enumerable<reservationWhereUniqueInput> | null
  set?: Enumerable<reservationWhereUniqueInput> | null
  disconnect?: Enumerable<reservationWhereUniqueInput> | null
  delete?: Enumerable<reservationWhereUniqueInput> | null
  update?: Enumerable<reservationUpdateWithWhereUniqueWithoutUserInput> | null
  updateMany?: Enumerable<reservationUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<reservationScalarWhereInput> | null
  upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutUserInput> | null
}

export type userUpdateWithoutRoomDataInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email?: string | null
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  id?: number | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password?: string | null
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeUpdateManyWithoutUserInput | null
  list?: listUpdateOneWithoutUserInput | null
  message?: messageUpdateOneWithoutUserInput | null
  reservation?: reservationUpdateManyWithoutUserInput | null
  review?: reviewUpdateManyWithoutUserInput | null
}

export type userUpsertWithoutRoomInput = {
  update: userUpdateWithoutRoomDataInput
  create: userCreateWithoutRoomInput
}

export type userUpdateOneWithoutRoomInput = {
  create?: userCreateWithoutRoomInput | null
  connect?: userWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: userUpdateWithoutRoomDataInput | null
  upsert?: userUpsertWithoutRoomInput | null
}

export type roomUpdateWithoutLikeDataInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  id?: number | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name?: string | null
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomUpdateconvenienceInput | null
  dates?: roomUpdatedatesInput | null
  user?: userUpdateOneWithoutRoomInput | null
  photo?: photoUpdateManyWithoutRoomInput | null
  reservation?: reservationUpdateManyWithoutRoomInput | null
  review?: reviewUpdateManyWithoutRoomInput | null
}

export type roomUpsertWithoutLikeInput = {
  update: roomUpdateWithoutLikeDataInput
  create: roomCreateWithoutLikeInput
}

export type roomUpdateOneRequiredWithoutLikeInput = {
  create?: roomCreateWithoutLikeInput | null
  connect?: roomWhereUniqueInput | null
  update?: roomUpdateWithoutLikeDataInput | null
  upsert?: roomUpsertWithoutLikeInput | null
}

export type likeUpdateWithoutUserDataInput = {
  id?: number | null
  room?: roomUpdateOneRequiredWithoutLikeInput | null
}

export type likeUpdateWithWhereUniqueWithoutUserInput = {
  where: likeWhereUniqueInput
  data: likeUpdateWithoutUserDataInput
}

export type likeUpsertWithWhereUniqueWithoutUserInput = {
  where: likeWhereUniqueInput
  update: likeUpdateWithoutUserDataInput
  create: likeCreateWithoutUserInput
}

export type likeUpdateManyWithoutUserInput = {
  create?: Enumerable<likeCreateWithoutUserInput> | null
  connect?: Enumerable<likeWhereUniqueInput> | null
  set?: Enumerable<likeWhereUniqueInput> | null
  disconnect?: Enumerable<likeWhereUniqueInput> | null
  delete?: Enumerable<likeWhereUniqueInput> | null
  update?: Enumerable<likeUpdateWithWhereUniqueWithoutUserInput> | null
  updateMany?: Enumerable<likeUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<likeScalarWhereInput> | null
  upsert?: Enumerable<likeUpsertWithWhereUniqueWithoutUserInput> | null
}

export type userUpdateWithoutMessageDataInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email?: string | null
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  id?: number | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password?: string | null
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeUpdateManyWithoutUserInput | null
  list?: listUpdateOneWithoutUserInput | null
  reservation?: reservationUpdateManyWithoutUserInput | null
  review?: reviewUpdateManyWithoutUserInput | null
  room?: roomUpdateManyWithoutUserInput | null
}

export type userUpsertWithoutMessageInput = {
  update: userUpdateWithoutMessageDataInput
  create: userCreateWithoutMessageInput
}

export type userUpdateOneWithoutMessageInput = {
  create?: userCreateWithoutMessageInput | null
  connect?: userWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: userUpdateWithoutMessageDataInput | null
  upsert?: userUpsertWithoutMessageInput | null
}

export type messageUpdateWithoutConversationDataInput = {
  id?: number | null
  message?: string | null
  user?: userUpdateOneWithoutMessageInput | null
}

export type messageUpsertWithoutConversationInput = {
  update: messageUpdateWithoutConversationDataInput
  create: messageCreateWithoutConversationInput
}

export type messageUpdateOneWithoutConversationInput = {
  create?: messageCreateWithoutConversationInput | null
  connect?: messageWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: messageUpdateWithoutConversationDataInput | null
  upsert?: messageUpsertWithoutConversationInput | null
}

export type conversationUpdateInput = {
  id?: number | null
  message?: messageUpdateOneWithoutConversationInput | null
}

export type conversationUpdateManyMutationInput = {
  id?: number | null
}

export type likeCreateInput = {
  room: roomCreateOneWithoutLikeInput
  user: userCreateOneWithoutLikeInput
}

export type likeUpdateInput = {
  id?: number | null
  room?: roomUpdateOneRequiredWithoutLikeInput | null
  user?: userUpdateOneRequiredWithoutLikeInput | null
}

export type likeUpdateManyMutationInput = {
  id?: number | null
}

export type userCreateWithoutListInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email: string
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password: string
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeCreateManyWithoutUserInput | null
  message?: messageCreateOneWithoutUserInput | null
  reservation?: reservationCreateManyWithoutUserInput | null
  review?: reviewCreateManyWithoutUserInput | null
  room?: roomCreateManyWithoutUserInput | null
}

export type userCreateOneWithoutListInput = {
  create?: userCreateWithoutListInput | null
  connect?: userWhereUniqueInput | null
}

export type listCreateInput = {
  name: string
  user?: userCreateOneWithoutListInput | null
}

export type userUpdateWithoutListDataInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email?: string | null
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  id?: number | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password?: string | null
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeUpdateManyWithoutUserInput | null
  message?: messageUpdateOneWithoutUserInput | null
  reservation?: reservationUpdateManyWithoutUserInput | null
  review?: reviewUpdateManyWithoutUserInput | null
  room?: roomUpdateManyWithoutUserInput | null
}

export type userUpsertWithoutListInput = {
  update: userUpdateWithoutListDataInput
  create: userCreateWithoutListInput
}

export type userUpdateOneWithoutListInput = {
  create?: userCreateWithoutListInput | null
  connect?: userWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: userUpdateWithoutListDataInput | null
  upsert?: userUpsertWithoutListInput | null
}

export type listUpdateInput = {
  id?: number | null
  name?: string | null
  user?: userUpdateOneWithoutListInput | null
}

export type listUpdateManyMutationInput = {
  id?: number | null
  name?: string | null
}

export type messageCreateInput = {
  message: string
  conversation?: conversationCreateOneWithoutMessageInput | null
  user?: userCreateOneWithoutMessageInput | null
}

export type messageUpdateInput = {
  id?: number | null
  message?: string | null
  conversation?: conversationUpdateOneWithoutMessageInput | null
  user?: userUpdateOneWithoutMessageInput | null
}

export type messageUpdateManyMutationInput = {
  id?: number | null
  message?: string | null
}

export type movieCreateInput = {
  minutes?: number | null
  title: string
}

export type movieUpdateInput = {
  id?: number | null
  minutes?: number | null
  title?: string | null
}

export type movieUpdateManyMutationInput = {
  id?: number | null
  minutes?: number | null
  title?: string | null
}

export type roomCreateWithoutPhotoInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name: string
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomCreateconvenienceInput | null
  dates?: roomCreatedatesInput | null
  user?: userCreateOneWithoutRoomInput | null
  like?: likeCreateManyWithoutRoomInput | null
  reservation?: reservationCreateManyWithoutRoomInput | null
  review?: reviewCreateManyWithoutRoomInput | null
}

export type roomCreateOneWithoutPhotoInput = {
  create?: roomCreateWithoutPhotoInput | null
  connect?: roomWhereUniqueInput | null
}

export type photoCreateInput = {
  caption?: string | null
  file?: string | null
  hostId?: number | null
  room?: roomCreateOneWithoutPhotoInput | null
}

export type roomUpdateWithoutPhotoDataInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  id?: number | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name?: string | null
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomUpdateconvenienceInput | null
  dates?: roomUpdatedatesInput | null
  user?: userUpdateOneWithoutRoomInput | null
  like?: likeUpdateManyWithoutRoomInput | null
  reservation?: reservationUpdateManyWithoutRoomInput | null
  review?: reviewUpdateManyWithoutRoomInput | null
}

export type roomUpsertWithoutPhotoInput = {
  update: roomUpdateWithoutPhotoDataInput
  create: roomCreateWithoutPhotoInput
}

export type roomUpdateOneWithoutPhotoInput = {
  create?: roomCreateWithoutPhotoInput | null
  connect?: roomWhereUniqueInput | null
  disconnect?: boolean | null
  delete?: boolean | null
  update?: roomUpdateWithoutPhotoDataInput | null
  upsert?: roomUpsertWithoutPhotoInput | null
}

export type photoUpdateInput = {
  caption?: string | null
  file?: string | null
  hostId?: number | null
  id?: number | null
  room?: roomUpdateOneWithoutPhotoInput | null
}

export type photoUpdateManyMutationInput = {
  caption?: string | null
  file?: string | null
  hostId?: number | null
  id?: number | null
}

export type reservationCreateInput = {
  check_in?: Date | string | null
  check_out?: Date | string | null
  in_progress?: boolean | null
  is_finished?: boolean | null
  user: userCreateOneWithoutReservationInput
  room: roomCreateOneWithoutReservationInput
}

export type reservationUpdateInput = {
  check_in?: Date | string | null
  check_out?: Date | string | null
  id?: number | null
  in_progress?: boolean | null
  is_finished?: boolean | null
  user?: userUpdateOneRequiredWithoutReservationInput | null
  room?: roomUpdateOneRequiredWithoutReservationInput | null
}

export type reservationUpdateManyMutationInput = {
  check_in?: Date | string | null
  check_out?: Date | string | null
  id?: number | null
  in_progress?: boolean | null
  is_finished?: boolean | null
}

export type reviewCreateInput = {
  accuracy?: number | null
  check_in?: number | null
  cleanliness?: number | null
  communication?: number | null
  createdAt?: string | null
  location?: number | null
  review?: string | null
  value?: number | null
  room: roomCreateOneWithoutReviewInput
  user?: userCreateOneWithoutReviewInput | null
}

export type reviewUpdateInput = {
  accuracy?: number | null
  check_in?: number | null
  cleanliness?: number | null
  communication?: number | null
  createdAt?: string | null
  id?: number | null
  location?: number | null
  review?: string | null
  value?: number | null
  room?: roomUpdateOneRequiredWithoutReviewInput | null
  user?: userUpdateOneWithoutReviewInput | null
}

export type reviewUpdateManyMutationInput = {
  accuracy?: number | null
  check_in?: number | null
  cleanliness?: number | null
  communication?: number | null
  createdAt?: string | null
  id?: number | null
  location?: number | null
  review?: string | null
  value?: number | null
}

export type roomCreateInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name: string
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomCreateconvenienceInput | null
  dates?: roomCreatedatesInput | null
  user?: userCreateOneWithoutRoomInput | null
  like?: likeCreateManyWithoutRoomInput | null
  photo?: photoCreateManyWithoutRoomInput | null
  reservation?: reservationCreateManyWithoutRoomInput | null
  review?: reviewCreateManyWithoutRoomInput | null
}

export type roomUpdateInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  id?: number | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name?: string | null
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomUpdateconvenienceInput | null
  dates?: roomUpdatedatesInput | null
  user?: userUpdateOneWithoutRoomInput | null
  like?: likeUpdateManyWithoutRoomInput | null
  photo?: photoUpdateManyWithoutRoomInput | null
  reservation?: reservationUpdateManyWithoutRoomInput | null
  review?: reviewUpdateManyWithoutRoomInput | null
}

export type roomUpdateManyMutationInput = {
  address?: string | null
  baths?: number | null
  bedrooms?: number | null
  beds?: number | null
  check_in?: Date | string | null
  check_out?: Date | string | null
  city?: string | null
  country?: string | null
  description?: string | null
  guests?: number | null
  houseRadio?: string | null
  houseType?: string | null
  id?: number | null
  instant_book?: boolean | null
  lat?: number | null
  lng?: number | null
  name?: string | null
  post_code?: string | null
  price?: number | null
  room_type?: string | null
  score?: number | null
  convenience?: roomUpdateconvenienceInput | null
  dates?: roomUpdatedatesInput | null
}

export type userCreateInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email: string
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password: string
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeCreateManyWithoutUserInput | null
  list?: listCreateOneWithoutUserInput | null
  message?: messageCreateOneWithoutUserInput | null
  reservation?: reservationCreateManyWithoutUserInput | null
  review?: reviewCreateManyWithoutUserInput | null
  room?: roomCreateManyWithoutUserInput | null
}

export type userUpdateInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email?: string | null
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  id?: number | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password?: string | null
  superhost?: boolean | null
  tokenVersion?: string | null
  like?: likeUpdateManyWithoutUserInput | null
  list?: listUpdateOneWithoutUserInput | null
  message?: messageUpdateOneWithoutUserInput | null
  reservation?: reservationUpdateManyWithoutUserInput | null
  review?: reviewUpdateManyWithoutUserInput | null
  room?: roomUpdateManyWithoutUserInput | null
}

export type userUpdateManyMutationInput = {
  avatar?: string | null
  birthdate?: Date | string | null
  currentcy?: string | null
  email?: string | null
  email_secret?: string | null
  email_verified?: boolean | null
  gender?: string | null
  id?: number | null
  language?: string | null
  login_method?: string | null
  name?: string | null
  password?: string | null
  superhost?: boolean | null
  tokenVersion?: string | null
}

export type NullableStringFilter = {
  equals?: string | null
  not?: string | null | NullableStringFilter
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}

export type NullableIntFilter = {
  equals?: number | null
  not?: number | null | NullableIntFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type IntFilter = {
  equals?: number | null
  not?: number | IntFilter | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type NullableDateTimeFilter = {
  equals?: Date | string | null
  not?: Date | string | null | NullableDateTimeFilter
  in?: Enumerable<Date | string> | null
  notIn?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
}

export type NullableBooleanFilter = {
  equals?: boolean | null
  not?: boolean | null | NullableBooleanFilter
}

export type NullableFloatFilter = {
  equals?: number | null
  not?: number | null | NullableFloatFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type StringFilter = {
  equals?: string | null
  not?: string | StringFilter | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}

export type likeFilter = {
  every?: likeWhereInput | null
  some?: likeWhereInput | null
  none?: likeWhereInput | null
}

export type photoFilter = {
  every?: photoWhereInput | null
  some?: photoWhereInput | null
  none?: photoWhereInput | null
}

export type reservationFilter = {
  every?: reservationWhereInput | null
  some?: reservationWhereInput | null
  none?: reservationWhereInput | null
}

export type reviewFilter = {
  every?: reviewWhereInput | null
  some?: reviewWhereInput | null
  none?: reviewWhereInput | null
}

export type roomFilter = {
  every?: roomWhereInput | null
  some?: roomWhereInput | null
  none?: roomWhereInput | null
}

export type conversationOrderByInput = {
  id?: OrderByArg | null
}

export type likeOrderByInput = {
  id?: OrderByArg | null
  roomId?: OrderByArg | null
  userId?: OrderByArg | null
  room?: OrderByArg | null
  user?: OrderByArg | null
}

export type photoOrderByInput = {
  caption?: OrderByArg | null
  file?: OrderByArg | null
  hostId?: OrderByArg | null
  id?: OrderByArg | null
  roomId?: OrderByArg | null
  room?: OrderByArg | null
}

export type reservationOrderByInput = {
  check_in?: OrderByArg | null
  check_out?: OrderByArg | null
  guestId?: OrderByArg | null
  id?: OrderByArg | null
  in_progress?: OrderByArg | null
  is_finished?: OrderByArg | null
  roomId?: OrderByArg | null
  user?: OrderByArg | null
  room?: OrderByArg | null
}

export type reviewOrderByInput = {
  accuracy?: OrderByArg | null
  check_in?: OrderByArg | null
  cleanliness?: OrderByArg | null
  communication?: OrderByArg | null
  createdAt?: OrderByArg | null
  id?: OrderByArg | null
  location?: OrderByArg | null
  review?: OrderByArg | null
  roomId?: OrderByArg | null
  userId?: OrderByArg | null
  value?: OrderByArg | null
  room?: OrderByArg | null
  user?: OrderByArg | null
}

export type roomOrderByInput = {
  address?: OrderByArg | null
  baths?: OrderByArg | null
  bedrooms?: OrderByArg | null
  beds?: OrderByArg | null
  check_in?: OrderByArg | null
  check_out?: OrderByArg | null
  city?: OrderByArg | null
  country?: OrderByArg | null
  description?: OrderByArg | null
  guests?: OrderByArg | null
  houseRadio?: OrderByArg | null
  houseType?: OrderByArg | null
  id?: OrderByArg | null
  instant_book?: OrderByArg | null
  lat?: OrderByArg | null
  lng?: OrderByArg | null
  name?: OrderByArg | null
  post_code?: OrderByArg | null
  price?: OrderByArg | null
  room_type?: OrderByArg | null
  score?: OrderByArg | null
  userId?: OrderByArg | null
  user?: OrderByArg | null
}

export type listOrderByInput = {
  id?: OrderByArg | null
  name?: OrderByArg | null
  userId?: OrderByArg | null
  user?: OrderByArg | null
}

export type messageOrderByInput = {
  conversationId?: OrderByArg | null
  id?: OrderByArg | null
  message?: OrderByArg | null
  userId?: OrderByArg | null
  conversation?: OrderByArg | null
  user?: OrderByArg | null
}

export type movieOrderByInput = {
  id?: OrderByArg | null
  minutes?: OrderByArg | null
  title?: OrderByArg | null
}

export type userOrderByInput = {
  avatar?: OrderByArg | null
  birthdate?: OrderByArg | null
  currentcy?: OrderByArg | null
  email?: OrderByArg | null
  email_secret?: OrderByArg | null
  email_verified?: OrderByArg | null
  gender?: OrderByArg | null
  id?: OrderByArg | null
  language?: OrderByArg | null
  login_method?: OrderByArg | null
  name?: OrderByArg | null
  password?: OrderByArg | null
  superhost?: OrderByArg | null
  tokenVersion?: OrderByArg | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
