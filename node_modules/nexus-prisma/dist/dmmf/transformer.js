"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const DmmfDocument_1 = require("./DmmfDocument");
exports.getTransformedDmmf = (photonClientPackagePath, options) => new DmmfDocument_1.DmmfDocument(transform(utils_1.getPhotonDmmf(photonClientPackagePath), options));
const addDefaultOptions = (givenOptions) => (Object.assign({ globallyComputedInputs: {} }, givenOptions));
function transform(document, options) {
    return {
        datamodel: transformDatamodel(document.datamodel),
        mappings: document.mappings,
        schema: transformSchema(document.schema, addDefaultOptions(options)),
    };
}
exports.transform = transform;
function transformDatamodel(datamodel) {
    return {
        enums: datamodel.enums,
        models: datamodel.models.map(model => (Object.assign(Object.assign({}, model), { fields: model.fields.map(field => (Object.assign(Object.assign({}, field), { kind: field.kind === 'object' ? 'relation' : field.kind }))) }))),
    };
}
function transformSchema(schema, { globallyComputedInputs }) {
    return {
        enums: schema.enums,
        inputTypes: schema.inputTypes.map(_ => transformInputType(_, globallyComputedInputs)),
        outputTypes: schema.outputTypes.map(o => (Object.assign(Object.assign({}, o), { fields: o.fields.map(f => (Object.assign(Object.assign({}, f), { args: f.args.map(transformArg), outputType: Object.assign(Object.assign({}, f.outputType), { type: getReturnTypeName(f.outputType.type) }) }))) }))),
    };
}
/**
 * Conversion from a Photon arg type to a GraphQL arg type using
 * heuristics. A conversion is needed becuase GraphQL does not
 * support union types on args, but Photon does.
 */
function transformArg(arg) {
    // FIXME: *Enum*Filter are currently empty
    let inputType = arg.inputType.some(a => a.kind === 'enum')
        ? arg.inputType[0]
        : arg.inputType.find(a => a.kind === 'object');
    if (!inputType) {
        inputType = arg.inputType[0];
    }
    return {
        name: arg.name,
        inputType: Object.assign(Object.assign({}, inputType), { type: getReturnTypeName(inputType.type) }),
        // FIXME Why?
        isRelationFilter: undefined,
    };
}
/**
 * Recursively looks for inputs that need a value from globallyComputedInputs
 * and populates them
 */
function addGloballyComputedInputs({ inputType, params, dmmf, data, }) {
    if (Array.isArray(data)) {
        return data.map(value => addGloballyComputedInputs({
            inputType,
            dmmf,
            params,
            data: value,
        }));
    }
    // Get values for computedInputs corresponding to keys that exist in inputType
    const computedInputValues = Object.keys(inputType.computedInputs).reduce((values, key) => (Object.assign(Object.assign({}, values), { [key]: inputType.computedInputs[key](params) })), {});
    // Combine computedInputValues with values provided by the user, recursing to add
    // global computedInputs to nested types
    return Object.keys(data).reduce((deeplyComputedData, fieldName) => {
        const field = inputType.fields.find(_ => _.name === fieldName);
        const fieldValue = field.inputType.kind === 'object'
            ? addGloballyComputedInputs({
                inputType: dmmf.getInputType(field.inputType.type),
                dmmf,
                params,
                data: data[fieldName],
            })
            : data[fieldName];
        return Object.assign(Object.assign({}, deeplyComputedData), { [fieldName]: fieldValue });
    }, computedInputValues);
}
function addComputedInputs({ dmmf, inputType, locallyComputedInputs, params, }) {
    return Object.assign(Object.assign({}, params.args), { data: Object.assign(Object.assign({}, addGloballyComputedInputs({
            inputType,
            dmmf,
            params,
            data: params.args.data,
        })), Object.entries(locallyComputedInputs).reduce((args, [fieldName, computeFieldValue]) => (Object.assign(Object.assign({}, args), { [fieldName]: computeFieldValue(params) })), {})) });
}
exports.addComputedInputs = addComputedInputs;
function transformInputType(inputType, globallyComputedInputs) {
    const fieldNames = inputType.fields.map(field => field.name);
    /**
     * Only global computed inputs are removed during schema transform.
     * Resolver level computed inputs are filtered as part of the
     * projecting process. They are then passed to addComputedInputs
     * at runtime so their values can be inferred alongside the
     * global values.
     */
    const globallyComputedInputsInType = Object.keys(globallyComputedInputs).reduce((args, key) => fieldNames.includes(key)
        ? Object.assign(args, { [key]: globallyComputedInputs[key] })
        : args, {});
    return Object.assign(Object.assign({}, inputType), { fields: inputType.fields
            .filter(field => !(field.name in globallyComputedInputs))
            .map(transformArg), computedInputs: globallyComputedInputsInType });
}
/**
 * Make the "return type" property type always be a string. In Photon
 * it is allowed to be a nested structured object but we want only the
 * reference-by-name form.
 *
 */
//
// TODO _why_ is the dmmf like this?
//
// FIXME `any` type becuase this is used by both outputType and inputType
// and there is currently no generic capturing both ideas.
//
function getReturnTypeName(type) {
    if (typeof type === 'string') {
        return type;
    }
    return type.name;
}
//# sourceMappingURL=transformer.js.map