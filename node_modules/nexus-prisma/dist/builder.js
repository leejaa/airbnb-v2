"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Nexus = __importStar(require("nexus"));
const path = __importStar(require("path"));
const dmmf_1 = require("./dmmf");
const GraphQL = __importStar(require("./graphql"));
const hooks_1 = require("./hooks");
const mapping_1 = require("./mapping");
const naming_strategies_1 = require("./naming-strategies");
const proxifier_1 = require("./proxifier");
const publisher_1 = require("./publisher");
const Typegen = __importStar(require("./typegen"));
const utils_1 = require("./utils");
/**
 * When dealing with list types we rely on the list type zero value (empty-list)
 * to represet the idea of null.
 *
 * For Prisma Client JS' part, it will never return null for list type fields nor will it
 * ever return null value list members.
 */
const dmmfListFieldTypeToNexus = (fieldType) => {
    return fieldType.isList
        ? {
            list: [true],
            nullable: false,
        }
        : {
            nullable: !fieldType.isRequired,
        };
};
function build(options) {
    const builder = new SchemaBuilder(options);
    return builder.build();
}
exports.build = build;
// The @types default is based on the priviledge given to such
// packages by TypeScript. For details refer to https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types
let defaultTypegenPath;
if (process.env.NEXUS_PRISMA_TYPEGEN_PATH) {
    defaultTypegenPath = process.env.NEXUS_PRISMA_TYPEGEN_PATH;
}
else if (process.env.NEXUS_PRISMA_LINK) {
    defaultTypegenPath = path.join(process.cwd(), 'node_modules/@types/nexus-prisma-typegen/index.d.ts');
}
else {
    defaultTypegenPath = path.join(__dirname, '../../@types/nexus-prisma-typegen/index.d.ts');
}
let defaultClientPath;
if (process.env.NEXUS_PRISMA_CLIENT_PATH) {
    defaultClientPath = process.env.NEXUS_PRISMA_CLIENT_PATH;
}
else if (process.env.NEXUS_PRISMA_LINK) {
    defaultClientPath = path.join(process.cwd(), '/node_modules/@prisma/photon');
    if (!dmmf_1.fatalIfOldPhotonIsInstalled(defaultClientPath)) {
        defaultClientPath = path.join(process.cwd(), '/node_modules/@prisma/client');
    }
}
else {
    defaultClientPath = '@prisma/photon';
    if (!dmmf_1.fatalIfOldPhotonIsInstalled(defaultClientPath)) {
        defaultClientPath = '@prisma/client';
    }
}
// NOTE This will be repalced by Nexus plugins once typegen integration is available.
const shouldGenerateArtifacts = process.env.NEXUS_SHOULD_GENERATE_ARTIFACTS === 'true'
    ? true
    : process.env.NEXUS_SHOULD_GENERATE_ARTIFACTS === 'false'
        ? false
        : Boolean(!process.env.NODE_ENV || process.env.NODE_ENV === 'development');
const defaultOptions = {
    shouldGenerateArtifacts,
    prismaClient: (ctx) => ctx.prisma,
    inputs: {
        prismaClient: defaultClientPath,
    },
    outputs: {
        typegen: defaultTypegenPath,
    },
    computedInputs: {},
};
class SchemaBuilder {
    constructor(options) {
        this.options = options;
        const config = Object.assign(Object.assign(Object.assign({}, defaultOptions), options), { inputs: Object.assign(Object.assign({}, defaultOptions.inputs), options.inputs), outputs: Object.assign(Object.assign({}, defaultOptions.outputs), options.outputs) });
        // Internally rename the 'computedInputs' plugin option to clarify scope
        this.globallyComputedInputs = config.computedInputs
            ? config.computedInputs
            : {};
        this.dmmf =
            options.dmmf ||
                dmmf_1.getTransformedDmmf(config.inputs.prismaClient, {
                    globallyComputedInputs: this.globallyComputedInputs,
                });
        this.publisher = new publisher_1.Publisher(this.dmmf, config.nexusBuilder);
        this.unknownFieldsByModel = {};
        this.argsNamingStrategy = naming_strategies_1.defaultArgsNamingStrategy;
        this.fieldNamingStrategy = naming_strategies_1.defaultFieldNamingStrategy;
        this.getPhoton = (ctx) => {
            const photon = config.prismaClient(ctx);
            utils_1.assertPhotonInContext(photon);
            return photon;
        };
        if (config.shouldGenerateArtifacts) {
            Typegen.generateSync({
                prismaClientPath: config.inputs.prismaClient,
                typegenPath: config.outputs.typegen,
            });
        }
    }
    /**
     * The build entrypoint, bringing together sub-builders.
     */
    build() {
        return [this.buildCRUD(), this.buildModel()];
    }
    /**
     * Build `t.crud` dynamic output property
     */
    buildCRUD() {
        return Nexus.dynamicOutputProperty({
            name: 'crud',
            typeDefinition: `: NexusPrisma<TypeName, 'crud'>`,
            // FIXME
            // Nexus should improve the type of typeName to be AllOutputTypes
            factory: ({ typeDef: t, typeName, stage }) => {
                if (typeName === GraphQL.rootNames.Subscription) {
                    // TODO Lets put a GitHub issue link in this error message
                    throw new Error(`t.crud is not yet supported on the 'Subscription' type.`);
                }
                if (typeName !== GraphQL.rootNames.Query &&
                    typeName !== GraphQL.rootNames.Mutation) {
                    throw new Error(`t.crud can only be used on GraphQL root types 'Query' & 'Mutation' but was used on '${typeName}'. Please use 't.model' instead`);
                }
                const publishers = mapping_1.getCrudMappedFields(typeName, this.dmmf).reduce((crud, mappedField) => {
                    const fieldPublisher = givenConfig => {
                        const inputType = this.dmmf.getInputType(mappedField.field.args[0].inputType.type);
                        const publisherConfig = this.buildPublisherConfig({
                            field: mappedField.field,
                            givenConfig: givenConfig ? givenConfig : {},
                        });
                        let fieldConfig = this.buildFieldConfig({
                            field: mappedField.field,
                            publisherConfig,
                            typeName,
                            operation: mappedField.operation,
                            resolve: (root, args, ctx, info) => {
                                const photon = this.getPhoton(ctx);
                                if (typeName === 'Mutation' &&
                                    (!utils_1.isEmptyObject(publisherConfig.locallyComputedInputs) ||
                                        !utils_1.isEmptyObject(this.globallyComputedInputs))) {
                                    args = dmmf_1.addComputedInputs({
                                        inputType,
                                        dmmf: this.dmmf,
                                        params: {
                                            info,
                                            args,
                                            ctx,
                                        },
                                        locallyComputedInputs: publisherConfig.locallyComputedInputs,
                                    });
                                }
                                return photon[mappedField.photonAccessor][mappedField.operation](args);
                            },
                        });
                        if (this.assertOutputTypeIsDefined(typeName, mappedField.field.name, publisherConfig.type, stage)) {
                            t.field(publisherConfig.alias, fieldConfig);
                        }
                        this.assertFilteringOrOrderingArgNameExists(typeName, mappedField.field.outputType.type, mappedField.field.name, publisherConfig, stage);
                        return crud;
                    };
                    crud[mappedField.field.name] = fieldPublisher;
                    return crud;
                }, {});
                return proxifier_1.proxifyPublishers(publishers, typeName, stage, this.options.onUnknownFieldName);
            },
        });
    }
    /**
     * Build the `t.model` dynamic output property.
     */
    buildModel() {
        return Nexus.dynamicOutputProperty({
            name: 'model',
            typeDefinition: `: NexusPrisma<TypeName, 'model'>`,
            /**
             * This factory implements what .model will actually be.
             *
             * If the user's GQL typedef name matches a PSL model name,
             * then we infer that the user is trying to create a mapping
             * between them. This is the implicit mapping case.
             *
             * Otherwise we need the user to specify what PSL model
             * their GQL object maps to. This is the explicit mapping case.
             *
             * In the implicit case we eagerly do the .model implementation,
             * but in the explicit case we return a function in order that the
             * user may specify the mapping.
             *
             * Examples:
             *
             *    // Given PSL that contains:
             *
             *    model User {
             *      id    String @unique @id @default(uuid())
             *      email String @unique
             *    }
             *
             *    // Example of implicit mapping
             *
             *    objectType({
             *      name: 'User',
             *      definition(t) {
             *        t.model.id()
             *        t.model.email()
             *      }
             *    })
             *
             *    // Example of explicit mapping
             *
             *    objectType({
             *      name: 'Customer',
             *      definition(t) {
             *        t.model('User').id()
             *        t.model('User').email()
             *      }
             *    })
             *
             */
            factory: ({ typeDef, typeName, stage }) => {
                const hasPrismaModel = this.dmmf.hasModel(typeName);
                if (hasPrismaModel) {
                    return this.internalBuildModel(typeName, typeDef, stage);
                }
                else {
                    const accessor = (modelName) => this.internalBuildModel(modelName, typeDef, stage);
                    return proxifier_1.proxifyModelFunction(accessor, typeName, stage, this.options.onUnknownPrismaModelName, this.unknownFieldsByModel);
                }
            },
        });
    }
    internalBuildModel(typeName, t, stage) {
        const model = this.dmmf.getModelOrThrow(typeName);
        const outputType = this.dmmf.getOutputType(model.name);
        const publishers = outputType.fields.reduce((acc, field) => {
            const fieldPublisher = givenConfig => {
                const publisherConfig = this.buildPublisherConfig({
                    field,
                    givenConfig: givenConfig !== null && givenConfig !== void 0 ? givenConfig : {},
                });
                if (!this.assertOutputTypeIsDefined(typeName, publisherConfig.alias, publisherConfig.type, stage)) {
                    return acc;
                }
                this.assertFilteringOrOrderingArgNameExists(typeName, field.outputType.type, publisherConfig.alias, publisherConfig, stage);
                const mapping = this.dmmf.getMapping(typeName);
                const idField = this.dmmf
                    .getModelOrThrow(typeName)
                    .fields.find(f => f.isId);
                if (!idField) {
                    throw new Error(`Your Prisma Model ${typeName} does not have an @id field. It's required for nexus-prisma to work.`);
                }
                const fieldConfig = this.buildFieldConfig({
                    field,
                    publisherConfig,
                    typeName,
                    resolve: field.outputType.kind === 'object'
                        ? (root, args, ctx) => {
                            const photon = this.getPhoton(ctx);
                            return photon[utils_1.lowerFirst(mapping.model)]['findOne']({
                                where: { [idField.name]: root[idField.name] },
                            })[field.name](args);
                        }
                        : undefined,
                });
                t.field(publisherConfig.alias, fieldConfig);
                return publishers;
            };
            acc[field.name] = fieldPublisher;
            return acc;
        }, {});
        return proxifier_1.proxifyPublishers(publishers, typeName, stage, this.options.onUnknownFieldName);
    }
    buildPublisherConfig(_a) {
        var { field } = _a, _b = _a.givenConfig, { computedInputs } = _b, otherConfig = __rest(_b, ["computedInputs"]);
        return Object.assign({ pagination: true, type: field.outputType.type, alias: field.name, locallyComputedInputs: computedInputs ? computedInputs : {} }, otherConfig);
    }
    buildFieldConfig(config) {
        return Object.assign(Object.assign({ type: this.publisher.outputType(config.publisherConfig.type, config.field) }, dmmfListFieldTypeToNexus(config.field.outputType)), { args: this.buildArgsFromField(config), resolve: config.resolve });
    }
    buildArgsFromField(config) {
        return this.determineArgs(config).reduce((acc, customArg) => (Object.assign(Object.assign({}, acc), { [customArg.arg.name]: this.publisher.inputType(customArg) })), {});
    }
    determineArgs(config) {
        if (config.typeName === 'Mutation') {
            return this.argsFromMutationField(config);
        }
        else if (config.operation === 'findOne') {
            return config.field.args.map(arg => ({
                arg,
                type: this.dmmf.getInputType(arg.inputType.type),
            }));
        }
        else {
            return this.argsFromQueryOrModelField(config);
        }
    }
    argsFromMutationField({ publisherConfig, field, }) {
        return field.args.map(arg => {
            const photonInputType = this.dmmf.getInputType(arg.inputType.type);
            /*
            Since globallyComputedInputs were already filtered during schema transformation,
            at this point we just need to filter at the resolver-level.
            */
            return {
                arg,
                type: Object.assign(Object.assign({}, photonInputType), { fields: publisherConfig.locallyComputedInputs
                        ? photonInputType.fields.filter(field => !(field.name in publisherConfig.locallyComputedInputs))
                        : photonInputType.fields }),
            };
        });
    }
    argsFromQueryOrModelField({ typeName, field, publisherConfig, }) {
        let args = [];
        if (publisherConfig.filtering) {
            const inputObjectTypeDefName = `${field.outputType.type}WhereInput`;
            const whereArg = field.args.find(arg => arg.inputType.type === inputObjectTypeDefName && arg.name === 'where');
            if (!whereArg) {
                throw new Error(`Could not find filtering argument for ${typeName}.${field.name}`);
            }
            const inputType = this.handleInputObjectCustomization(publisherConfig.filtering, inputObjectTypeDefName, field.name, typeName);
            if (inputType.fields.length > 0) {
                args.push({
                    arg: whereArg,
                    type: inputType,
                });
            }
        }
        if (publisherConfig.ordering) {
            const orderByTypeName = `${field.outputType.type}OrderByInput`;
            const orderByArg = field.args.find(arg => arg.inputType.type === orderByTypeName && arg.name === 'orderBy');
            if (!orderByArg) {
                throw new Error(`Could not find ordering argument for ${typeName}.${field.name}`);
            }
            const inputType = this.handleInputObjectCustomization(publisherConfig.ordering, orderByTypeName, field.name, typeName);
            if (inputType.fields.length > 0) {
                args.push({
                    arg: orderByArg,
                    type: inputType,
                });
            }
        }
        if (publisherConfig.pagination) {
            const paginationKeys = ['first', 'last', 'before', 'after', 'skip'];
            const paginationsArgs = publisherConfig.pagination === true
                ? field.args.filter(a => paginationKeys.includes(a.name))
                : field.args.filter(arg => publisherConfig.pagination[arg.name] === true);
            args.push(...paginationsArgs.map(a => {
                if (a.inputType.kind === 'scalar' || a.inputType.kind === 'enum') {
                    return {
                        arg: a,
                        type: { name: a.inputType.type },
                    };
                }
                else {
                    return {
                        arg: a,
                        type: this.dmmf.inputTypesIndex[a.inputType.type],
                    };
                }
            }));
        }
        return args;
    }
    /**
     * This handles "tailored field feature publishing".
     *
     * With tailord field feature publishing, users can specify that only some
     * fields of the PSL model are exposed under the given field feature. For
     * example, in the following...
     *
     * ```ts
     * t.model.friends({ filtering: { firstName: true, location: true } })
     * ```
     *
     * ...the field feature is "filtering" and the user has tailored it so that
     * only "firstName" and "location" of the field's type (e.g. "User") are
     * exposed to filtering on this field. So the resulting GQL TypeDef would look
     * something like:
     *
     * ```ts
     * ...
     * friends(where: { firstName: ..., location: ..., }): [User]
     * ...
     * ```
     */
    handleInputObjectCustomization(fieldWhitelist, inputTypeName, fieldName, graphQLTypeName) {
        const photonObject = this.dmmf.getInputType(inputTypeName);
        // If the publishing for this field feature (filtering, ordering, ...)
        // has not been tailored then we may simply pass through the backing
        // version as-is.
        //
        if (fieldWhitelist === true) {
            return photonObject;
        }
        // REFACTOR use an intersection function
        const whitelistedFieldNames = Object.keys(fieldWhitelist);
        const userExposedObjectFields = photonObject.fields.filter(field => whitelistedFieldNames.includes(field.name));
        const uniqueName = photonObject.isWhereType
            ? this.argsNamingStrategy.whereInput(graphQLTypeName, fieldName)
            : this.argsNamingStrategy.orderByInput(graphQLTypeName, fieldName);
        return Object.assign(Object.assign({}, photonObject), { name: uniqueName, fields: userExposedObjectFields });
    }
    assertOutputTypeIsDefined(typeName, fieldName, outputType, stage) {
        if (this.options.nexusBuilder.hasType(outputType) ||
            GraphQL.isScalarType(outputType) || // scalar types are auto-published
            !this.dmmf.hasModel(outputType) // output types that are not models are auto-published
        ) {
            return true;
        }
        const message = `Your GraphQL \`${typeName}\` object definition is projecting a field \`${fieldName}\` with \`${outputType}\` as output type, but \`${outputType}\` is not defined in your GraphQL Schema`;
        hooks_1.raiseErrorOrTriggerHook(this.options.onUnknownFieldType, {
            unknownFieldType: outputType,
            typeName,
            fieldName,
            error: new Error(message),
        }, message, stage);
        return false;
    }
    assertArgNameExists(parentTypeName, prismaOutputTypeName, fieldName, config, stage, configProperty) {
        if (!config[configProperty] || config[configProperty] === true) {
            return true;
        }
        const argNames = Object.keys(config[configProperty]);
        const typeNameFieldNames = this.dmmf
            .getModelOrThrow(prismaOutputTypeName)
            .fields.map(f => f.name);
        const wrongArgNames = argNames.filter(filteringFieldName => !typeNameFieldNames.includes(filteringFieldName));
        if (wrongArgNames.length === 0) {
            return true;
        }
        const actionWord = configProperty === 'filtering' ? 'filter' : 'order';
        const renderMessage = (argName) => `Your GraphQL \`${parentTypeName}\` object definition is projecting a relational field \`${fieldName}\`. On it, you are declaring that clients be able to ${actionWord} by Prisma \`${prismaOutputTypeName}\` model field \`${argName}\`. However, your Prisma model \`${prismaOutputTypeName}\` model has no such field \`${argName}\``;
        const message = wrongArgNames
            .map(argName => renderMessage(argName))
            .join('\n');
        hooks_1.raiseErrorOrTriggerHook(this.options.onUnknownArgName, {
            unknownArgNames: wrongArgNames,
            typeName: prismaOutputTypeName,
            fieldName,
            error: new Error(message),
        }, message, stage);
        return { wrongArgNames };
    }
    assertFilteringOrOrderingArgNameExists(parentTypeName, prismaOutputTypeName, fieldName, config, stage) {
        this.assertArgNameExists(parentTypeName, prismaOutputTypeName, fieldName, config, stage, 'filtering');
        this.assertArgNameExists(parentTypeName, prismaOutputTypeName, fieldName, config, stage, 'ordering');
    }
}
exports.SchemaBuilder = SchemaBuilder;
//# sourceMappingURL=builder.js.map